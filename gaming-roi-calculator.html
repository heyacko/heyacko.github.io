<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaming ROI Calculator</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        /* Gaming ROI Calculator specific styles */
        /* Custom styles for gaming calculator specific elements */
        
        /* Add proper spacing between cards */
        .shared-card + .shared-card {
            margin-top: 25px;
        }

        /* Layout for primary metrics side by side */
        .primary-metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .primary-metrics .primary-metric {
            text-align: center;
        }

        @media (max-width: 768px) {
            .primary-metrics {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
        }

        /* Game list styling */
        .games-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .game-info {
            flex: 1;
        }

        .game-name {
            font-weight: 600;
            color: #2c5aa0;
            margin-bottom: 2px;
        }

        .game-details {
            font-size: 0.9rem;
            color: #666;
        }

        .remove-game-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .remove-game-btn:hover {
            background: #ff5252;
        }

        /* Individual game metrics table styling */
        .games-metrics {
            margin-bottom: 25px;
        }

        .games-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .games-table th,
        .games-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .games-table th {
            background: rgba(255, 255, 255, 0.2);
            font-weight: 600;
            color: #2c5aa0;
            font-family: 'Lucida Console', Monaco, 'Courier New', monospace;
        }

        .games-table td {
            color: #333;
        }

        .games-table tr:last-child td {
            border-bottom: none;
        }

        .games-table .game-name {
            font-weight: 600;
            color: #2c5aa0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .game-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            object-fit: cover;
        }

        .games-table .metric-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .games-table .cost-per-hour {
            text-align: right;
        }

        .games-table .hours-work {
            text-align: right;
        }

        /* Color coding for metrics based on verdict bins */
        .metric-legendary { color: #4CAF50 !important; } /* Green - $0-1/hr */
        .metric-elite { color: #8BC34A !important; } /* Light Green - $1-3/hr */
        .metric-solid { color: #2196F3 !important; } /* Blue - $3-8/hr */
        .metric-reasonable { color: #FF9800 !important; } /* Orange - $8-15/hr */
        .metric-premium { color: #FF5722 !important; } /* Deep Orange - $15-30/hr */
        .metric-yikes { color: #F44336 !important; } /* Red - $30+/hr */

        /* Apply color coding to primary metrics */
        .primary-metric .value.legendary { color: #4CAF50; }
        .primary-metric .value.elite { color: #8BC34A; }
        .primary-metric .value.solid { color: #2196F3; }
        .primary-metric .value.reasonable { color: #FF9800; }
        .primary-metric .value.premium { color: #FF5722; }
        .primary-metric .value.yikes { color: #F44336; }

        .add-game-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            align-self: flex-end;
            margin-top: 30px; /* Match the label height to align with input fields */
        }

        .add-game-btn:hover {
            background: #4a90e2;
            transform: translateY(-2px);
        }

        /* Steam connection styling */
        .steam-connection-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .steam-description {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        .steam-input-row {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .steam-input-row .input-group {
            flex: 1;
        }

        .steam-connect-btn {
            background: #1b2838;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .steam-connect-btn:hover {
            background: #2a475e;
            transform: translateY(-2px);
        }

        .steam-connect-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .steam-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .steam-status.success {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .steam-status.error {
            background: rgba(244, 67, 54, 0.1);
            color: #F44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .steam-status.loading {
            background: rgba(33, 150, 243, 0.1);
            color: #2196F3;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        /* Loading bar styling - file download style */
        .loading-bar-container {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 12px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #2196F3, #64b5f6);
            transition: width 0.3s ease;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .loading-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.6) 50%,
                transparent 100%
            );
            animation: shimmer 1.2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { 
                transform: translateX(-100%); 
            }
            100% { 
                transform: translateX(200%); 
            }
        }

        .loading-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.85rem;
            font-weight: 600;
            color: #2c5aa0;
            z-index: 1;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        .steam-message {
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        /* Two-column layout for Steam and Income */
        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }

        .column {
            display: flex;
            flex-direction: column;
        }

        .column h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .column-description {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .two-column-layout {
                grid-template-columns: 1fr;
                gap: 25px;
            }
        }

        /* Add game section styling */
        .add-game-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .add-game-section h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #2c5aa0;
            font-size: 1rem;
        }

        #gamesListContent {
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* Scrollable pane ‚Äì default fallback; JS will refine height to ~10 rows */
            max-height: 520px;
            overflow-y: auto;
            padding-right: 6px; /* room for scrollbar */
        }

        /* Metrics pane scroll container */
        #gamesMetrics {
            max-height: 520px; /* JS will refine to exactly ~10 rows incl. header */
            overflow-y: auto;
            display: block;
            padding-right: 6px;
        }

        /* Inline input row for Steam connection */
        .input-row-inline {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .flex-grow {
            flex: 1;
        }

        /* Constrain button width in inline row */
        .input-row-inline .input-group:last-child {
            flex: 0.02 0 auto;
            min-width: fit-content;
        }

        /* Sortable table headers */
        .games-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px;
        }

        .games-table th.sortable:hover {
            background: rgba(44, 90, 160, 0.15);
        }

        .games-table th.sortable::after {
            content: '‚áÖ';
            position: absolute;
            right: 8px;
            opacity: 0.3;
            font-size: 12px;
        }

        .games-table th.sortable.sort-asc::after {
            content: '‚ñ≤';
            opacity: 0.8;
        }

        .games-table th.sortable.sort-desc::after {
            content: '‚ñº';
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .input-row-inline {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-row-inline .input-group label {
                display: block;
            }
        }

        /* Game list enhancements for Steam integration */
        .game-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr auto;
            gap: 15px;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 10px;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .game-name {
            font-weight: 600;
            color: #2c5aa0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .steam-badge {
            background: #1b2838;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .game-details {
            font-size: 0.85rem;
            color: #666;
        }

        .game-editable-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .game-editable-field label {
            font-size: 0.75rem;
            color: #666;
            font-weight: 600;
        }

        .game-editable-field input {
            padding: 6px 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: #333;
            font-size: 0.9rem;
            width: 100px;
            transition: all 0.2s ease;
        }

        .game-editable-field input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.1);
        }

        .game-editable-field input.needs-value {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.05);
        }

        .game-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        @media (max-width: 768px) {
            .game-item {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .game-editable-field input {
                width: 100%;
            }
        }

        .input-section {
            margin-bottom: 25px;
        }

        .input-section h3 {
            font-family: 'Lucida Console', Monaco, 'Courier New', monospace;
            color: #2c5aa0;
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .input-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        .input-group {
            flex: 1;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c5aa0;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            font-size: 16px;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .input-group input.error {
            border-color: #d0021b;
        }

        .error-message {
            color: #d0021b;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radio-option input[type="radio"] {
            margin: 0;
        }

        .radio-option label {
            margin: 0;
            cursor: pointer;
        }

        .calculate-btn {
            appearance: none;
            border: none;
            background: linear-gradient(135deg, var(--accent), #5ba0f2);
            color: white;
            padding: 18px 32px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            min-height: 56px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        .calculate-btn:hover {
            background: linear-gradient(135deg, #5ba0f2, #6bb0ff);
            box-shadow: 0 4px 16px rgba(74, 144, 226, 0.2);
            transform: translateY(-2px);
        }

        .calculate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Shiny animation when games are populated */
        .calculate-btn.shiny::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                120deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shine 2.5s infinite;
        }

        @keyframes shine {
            0% {
                transform: translateX(-100%) translateY(-100%) rotate(45deg);
            }
            100% {
                transform: translateX(100%) translateY(100%) rotate(45deg);
            }
        }

        .results {
            display: none;
        }

        .primary-metric {
            text-align: center;
            margin-bottom: 25px;
        }

        .primary-metric .value {
            font-size: 3rem;
            font-weight: 700;
            color: #2c5aa0;
            margin-bottom: 5px;
        }

        .primary-metric .label {
            color: #7a9cc6;
            font-size: 1.1rem;
        }

        .secondary-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .metric {
            text-align: center;
            padding: 15px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .metric .value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c5aa0;
            margin-bottom: 5px;
        }

        .metric .label {
            color: #7a9cc6;
            font-size: 0.9rem;
        }

        .verdict {
            text-align: center;
            padding: 20px;
            background: rgba(74, 144, 226, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 144, 226, 0.2);
            border-radius: 12px;
            border-left: 4px solid var(--accent);
        }

        .verdict-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c5aa0;
            margin-bottom: 5px;
        }

        .verdict-subtext {
            color: #7a9cc6;
            font-size: 0.9rem;
        }

        .chart-container {
            margin-top: 20px;
        }

        /* Two-chart row layout */
        .two-chart-row {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-top: 20px;
        }

        .two-chart-row .chart-container {
            margin-top: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .two-chart-row .chart-container canvas {
            max-height: 350px;
        }

        @media (max-width: 1024px) {
            .two-chart-row {
                grid-template-columns: 1fr;
            }
            
            .two-chart-row .chart-container canvas {
                max-height: none;
            }
        }

        #comparisonChart {
            height: 350px !important;
        }

        /* Make scatter chart wrapper square and full width */
        .scatter-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
        }

        #scatterChart {
            width: 100% !important;
            height: 100% !important;
            position: relative;
            z-index: 10;
        }

        /* Crosshair lines for quadrants */
        .scatter-crosshair {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .crosshair-h {
            position: absolute;
            width: 100%;
            height: 3px;
            background: rgba(80, 80, 80, 0.7);
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .crosshair-v {
            position: absolute;
            width: 3px;
            height: 100%;
            background: rgba(80, 80, 80, 0.7);
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }

        .crosshair-arrow {
            display: none;
        }

        /* Quadrant background colors */
        .scatter-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            background: 
                linear-gradient(to right, 
                    rgba(244, 67, 54, 0.08) 0%, 
                    rgba(244, 67, 54, 0.08) 50%, 
                    rgba(255, 152, 0, 0.08) 50%, 
                    rgba(255, 152, 0, 0.08) 100%
                ),
                linear-gradient(to bottom, 
                    transparent 0%, 
                    transparent 50%, 
                    rgba(0, 0, 0, 0.05) 50%, 
                    rgba(0, 0, 0, 0.05) 100%
                );
        }

        /* Individual quadrant backgrounds using separate approach */
        .scatter-wrapper::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 50%;
            height: 50%;
            background: rgba(33, 150, 243, 0.08); /* Blue - Casual win */
            z-index: 0;
            pointer-events: none;
        }

        .scatter-wrapper .scatter-crosshair::before {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 50%;
            height: 50%;
            background: rgba(76, 175, 80, 0.08); /* Green - Evergreen value */
            z-index: 0;
            pointer-events: none;
        }

        /* Quadrant labels */
        .quadrant-label {
            position: absolute;
            font-size: 14px;
            font-weight: 600;
            font-family: 'Lucida Console', Monaco, 'Courier New', monospace;
            opacity: 0.6;
            pointer-events: none;
            z-index: 2;
        }

        .quadrant-tl {
            top: 10px;
            left: 10px;
            color: rgba(244, 67, 54, 1); /* Red - Backlog shame */
        }

        .quadrant-tr {
            top: 10px;
            right: 10px;
            color: rgba(255, 152, 0, 1); /* Orange - Luxury hobby */
        }

        .quadrant-bl {
            bottom: 10px;
            left: 10px;
            color: rgba(33, 150, 243, 1); /* Blue - Casual win */
        }

        .quadrant-br {
            bottom: 10px;
            right: 10px;
            color: rgba(76, 175, 80, 1); /* Green - Evergreen value */
        }

        .accordion {
            margin-top: 20px;
        }

        .accordion-header {
            background: rgba(74, 144, 226, 0.1);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .accordion-header:hover {
            background: rgba(74, 144, 226, 0.15);
        }

        .accordion-header h4 {
            margin: 0;
            color: #2c5aa0;
            font-family: 'Lucida Console', Monaco, 'Courier New', monospace;
        }

        .accordion-content {
            display: none;
            padding: 20px 0;
        }

        .accordion-content.expanded {
            display: block;
        }

        .assumption-item {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .assumption-item label {
            min-width: 120px;
            font-weight: 600;
            color: #2c5aa0;
        }

        .assumption-item input {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--line);
            border-radius: 4px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .assumption-item input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.1);
        }

        .reset-btn {
            appearance: none;
            border: 1px solid rgba(74, 144, 226, 0.3);
            background: var(--glass);
            backdrop-filter: blur(10px);
            color: var(--ink);
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .reset-btn:hover {
            background: rgba(74, 144, 226, 0.1);
            border-color: var(--accent);
            box-shadow: 0 4px 16px rgba(74, 144, 226, 0.2);
        }

        .share-section {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .share-btn {
            appearance: none;
            border: 1px solid rgba(126, 211, 33, 0.3);
            background: rgba(126, 211, 33, 0.1);
            backdrop-filter: blur(10px);
            color: var(--ok);
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .share-btn:hover {
            background: rgba(126, 211, 33, 0.2);
            border-color: var(--ok);
            box-shadow: 0 4px 16px rgba(126, 211, 33, 0.2);
        }

        @media (max-width: 768px) {
            .input-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .radio-group {
                flex-direction: column;
                gap: 10px;
            }
            
            .secondary-metrics {
                grid-template-columns: 1fr;
            }
            
            .primary-metric .value {
                font-size: 2.5rem;
            }
        }

        /* Card movement animations */
        @keyframes slideUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        @keyframes slideIn {
            0% {
                transform: translateY(-30px) scale(0.95);
                opacity: 0;
            }
            60% {
                transform: translateY(5px) scale(1.02);
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .card-slide-up {
            animation: slideUp 0.4s ease-out forwards;
        }

        .card-slide-in {
            animation: slideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
    </style>
</head>
<body>
    <div class="shared-wrap">
        <div class="shared-card">
            <h1 class="shared-h1">Gaming ROI Calculator</h1>
            <p class="shared-sub">Calculate the true cost of your gaming habit and see how it stacks up against other entertainment.</p>
            <a href="index.html" class="shared-btn-ghost">üè† Home</a>
        </div>

        <div class="shared-card" id="inputCard">
            <h3>Connect Steam Account</h3>
            <p class="steam-description">Connect your Steam account to automatically import your game library and hours played.</p>
            <div class="input-section">
                <div class="input-row-inline">
                    <div class="input-group flex-grow">
                        <label for="steamId">Steam ID or Profile URL</label>
                        <input type="text" id="steamId" placeholder="e.g., 76561198000000000 or https://steamcommunity.com/id/username">
                        <div class="error-message" id="steamIdError"></div>
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button type="button" class="steam-connect-btn" id="steamConnectBtn">Connect Steam</button>
                    </div>
                </div>
                <div class="steam-status" id="steamStatus" style="display: none;"></div>
            </div>

            <button class="calculate-btn" id="calculateBtn">Calculate ROI</button>

            <div class="games-list-section" id="gamesListSection">
                <h3 class="games-list-header" id="gamesListHeader" style="cursor: pointer;">
                    Your Games <span id="gamesListToggle">‚ñº</span>
                </h3>
                <div class="games-list" id="gamesList">
                    <!-- Add Game Section (always visible in dropdown) -->
                    <div class="add-game-section">
                        <h4>Add Game Manually</h4>
                        <div class="input-row">
                            <div class="input-group">
                                <label for="gameName">Game name *</label>
                                <input type="text" id="gameName" placeholder="e.g., Elden Ring">
                                <div class="error-message" id="gameNameError"></div>
                            </div>
                            <div class="input-group">
                                <label for="gameCost">Cost of game ($) *</label>
                                <input type="number" id="gameCost" placeholder="60" min="0" step="0.01">
                                <div class="error-message" id="gameCostError"></div>
                            </div>
                            <div class="input-group">
                                <label for="dlcCost">DLC cost ($)</label>
                                <input type="number" id="dlcCost" placeholder="0" min="0" step="0.01">
                            </div>
                            <div class="input-group">
                                <label for="hoursPlayed">Hours played *</label>
                                <input type="number" id="hoursPlayed" placeholder="40" min="0" step="0.1">
                                <div class="error-message" id="hoursPlayedError"></div>
                            </div>
                            <div class="input-group">
                                <button type="button" class="add-game-btn" id="addGameBtn">Add Game</button>
                            </div>
                        </div>
                    </div>

                    <!-- Games will be listed here -->
                    <div id="gamesListContent"></div>
                </div>
            </div>
        </div>

        <div class="shared-card verdict-card" id="verdictCard" style="display: none;">
            <div class="verdict">
                <div class="verdict-text" id="verdictText">Ready to calculate!</div>
                <div class="verdict-subtext" id="verdictSubtext">Add games and calculate to see your gaming ROI verdict.</div>
            </div>
        </div>

        <div class="shared-card results" id="resultsCard">
            <div class="primary-metrics">
                <div class="primary-metric">
                    <div class="value" id="aggregateCostPerHour">$0.00/hr</div>
                    <div class="label">Aggregate cost per hour of gaming</div>
                </div>
                <div class="primary-metric">
                    <div class="value" id="totalGamingHours">0</div>
                    <div class="label">Total Gaming Hours</div>
                </div>
                <div class="primary-metric">
                    <div class="value" id="totalCostOfGaming">$0.00</div>
                    <div class="label">Total Cost of Gaming</div>
                </div>
                <div class="primary-metric">
                    <div class="value" id="neverPlayedCost">$0.00</div>
                    <div class="label">Money spent on games you never played</div>
                </div>
            </div>

            <div class="two-chart-row">
                <div class="chart-container">
                    <h3 style="text-align: center; margin-bottom: 20px; color: #2c5aa0; font-family: 'Lucida Console', Monaco, 'Courier New', monospace;">Gaming Spend Breakdown</h3>
                    <canvas id="spendPieChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3 style="text-align: center; margin-bottom: 20px; color: #2c5aa0; font-family: 'Lucida Console', Monaco, 'Courier New', monospace;">Cost Per Hour Comparison</h3>
                    <canvas id="comparisonChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3 style="text-align: center; margin-bottom: 20px; color: #2c5aa0; font-family: 'Lucida Console', Monaco, 'Courier New', monospace;">Gaming Efficiency: Investment vs Value</h3>
                <div class="scatter-wrapper">
                    <canvas id="scatterChart"></canvas>
                    <div class="scatter-crosshair">
                        <div class="crosshair-h"></div>
                        <div class="crosshair-v"></div>
                        <!-- Quadrant labels -->
                        <div class="quadrant-label quadrant-tl">Backlog shame</div>
                        <div class="quadrant-label quadrant-tr">Luxury hobby</div>
                        <div class="quadrant-label quadrant-bl">Casual win</div>
                        <div class="quadrant-label quadrant-br">Evergreen value</div>
                    </div>
                </div>
            </div>

            <div class="individual-games-section" id="individualGamesSection" style="display: none;">
                <h3>Individual Game Metrics</h3>
                <div class="games-metrics" id="gamesMetrics"></div>
            </div>

            <div class="share-section">
                <button class="share-btn" id="shareBtn">Copy Summary</button>
                <span id="shareStatus"></span>
            </div>
        </div>

        <div class="shared-card">
            <div class="accordion">
                <div class="accordion-header" id="accordionHeader">
                    <h4>Advanced Assumptions</h4>
                    <span id="accordionToggle">‚ñº</span>
                </div>
                <div class="accordion-content" id="accordionContent">
                    <p>Edit these benchmark assumptions to customize your comparison chart:</p>
                    
                    <div class="assumption-item">
                        <label>Movie ticket:</label>
                        <input type="number" id="moviePrice" value="15" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="movieHours" value="2.5" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Disneyland:</label>
                        <input type="number" id="disneyPrice" value="160" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="disneyHours" value="12" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Netflix:</label>
                        <input type="number" id="netflixPrice" value="16" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="netflixHours" value="40" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Max:</label>
                        <input type="number" id="maxPrice" value="16" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="maxHours" value="25" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>YouTube Premium:</label>
                        <input type="number" id="youtubePrice" value="14" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="youtubeHours" value="60" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Concert Ticket:</label>
                        <input type="number" id="concertPrice" value="100" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="concertHours" value="3" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Basketball Ticket:</label>
                        <input type="number" id="basketballPrice" value="120" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="basketballHours" value="3" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Gym Membership:</label>
                        <input type="number" id="gymPrice" value="60" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="gymHours" value="12" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Spotify Premium:</label>
                        <input type="number" id="spotifyPrice" value="11" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="spotifyHours" value="60" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <button class="reset-btn" id="resetBtn">Reset to Defaults</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Suppress browser extension errors that don't affect functionality
        window.addEventListener('error', function(event) {
            if (event.message && event.message.includes('message channel closed')) {
                event.preventDefault();
                return true;
            }
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            if (event.reason && event.reason.message && event.reason.message.includes('message channel closed')) {
                event.preventDefault();
                return true;
            }
        });
        
        // DOM elements
        const gameNameInput = document.getElementById('gameName');
        const gameCostInput = document.getElementById('gameCost');
        const dlcCostInput = document.getElementById('dlcCost');
        const hoursPlayedInput = document.getElementById('hoursPlayed');
        const addGameBtn = document.getElementById('addGameBtn');
        const gamesListSection = document.getElementById('gamesListSection');
        const gamesList = document.getElementById('gamesList');
        const gamesListContent = document.getElementById('gamesListContent');
        
        // Steam API elements
        const steamIdInput = document.getElementById('steamId');
        const steamConnectBtn = document.getElementById('steamConnectBtn');
        const steamStatus = document.getElementById('steamStatus');
        
        const calculateBtn = document.getElementById('calculateBtn');
        const verdictCard = document.getElementById('verdictCard');
        const resultsCard = document.getElementById('resultsCard');
        
        // Results elements
        const aggregateCostPerHourEl = document.getElementById('aggregateCostPerHour');
        const neverPlayedCostEl = document.getElementById('neverPlayedCost');
        const verdictTextEl = document.getElementById('verdictText');
        const verdictSubtextEl = document.getElementById('verdictSubtext');
        const individualGamesSection = document.getElementById('individualGamesSection');
        const gamesMetrics = document.getElementById('gamesMetrics');
        
        // Charts
        let comparisonChart = null;
        let scatterChart = null;
        let spendPieChart = null;
        
        // Data storage
        let games = [];
        
        // Steam API configuration
        const STEAM_API_KEY = 'B82CDB439F57BD8533FB8A145A61E16F';
        const STEAM_API_BASE = 'https://api.steampowered.com';
        // CORS proxy to bypass browser restrictions
        const CORS_PROXY = 'https://corsproxy.io/?';
        
        // Advanced assumptions
        const accordionHeader = document.getElementById('accordionHeader');
        const accordionContent = document.getElementById('accordionContent');
        const accordionToggle = document.getElementById('accordionToggle');
        const resetBtn = document.getElementById('resetBtn');
        
        // Share functionality
        const shareBtn = document.getElementById('shareBtn');
        const shareStatus = document.getElementById('shareStatus');
        
        // Games list toggle
        const gamesListHeader = document.getElementById('gamesListHeader');
        const gamesListToggle = document.getElementById('gamesListToggle');

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            loadFromURL();
            // Apply initial scroll sizing if content exists
            setTimeout(applyScrollableHeights, 0);
        });

        function updateCalculateButtonState() {
            // Add shiny animation when games are populated
            if (games.length > 0) {
                calculateBtn.classList.add('shiny');
            } else {
                calculateBtn.classList.remove('shiny');
            }
        }

        function setupEventListeners() {
            // Game management
            addGameBtn.addEventListener('click', addGame);
            
            // Steam connection
            steamConnectBtn.addEventListener('click', connectSteam);
            
            // Calculate button
            calculateBtn.addEventListener('click', calculateROI);
            
            // Advanced assumptions
            accordionHeader.addEventListener('click', toggleAccordion);
            resetBtn.addEventListener('click', resetAssumptions);
            
            const assumptionInputs = [
                'moviePrice', 'movieHours', 'disneyPrice', 'disneyHours',
                'concertPrice', 'concertHours', 'basketballPrice', 'basketballHours',
                'netflixPrice', 'netflixHours', 'maxPrice', 'maxHours',
                'youtubePrice', 'youtubeHours', 'gymPrice', 'gymHours',
                'spotifyPrice', 'spotifyHours'
            ];
            assumptionInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    if (resultsCard.style.display !== 'none') {
                        updateChart();
                    }
                });
            });
            
            // Share button
            shareBtn.addEventListener('click', copySummary);
            
            // Games list toggle
            gamesListHeader.addEventListener('click', toggleGamesList);
        }

        function addGame() {
            const gameName = gameNameInput.value.trim();
            const gameCost = parseFloat(gameCostInput.value);
            const dlcCost = parseFloat(dlcCostInput.value) || 0;
            const hoursPlayed = parseFloat(hoursPlayedInput.value);
            
            // Validate inputs
            if (!gameName) {
                showError('gameNameError', 'Please enter a game name');
                return;
            }
            if (isNaN(gameCost) || gameCost < 0) {
                showError('gameCostError', 'Please enter a valid game cost');
                return;
            }
            if (isNaN(hoursPlayed) || hoursPlayed < 0) {
                showError('hoursPlayedError', 'Please enter valid hours played (‚â• 0)');
                return;
            }
            
            // Clear errors
            hideError('gameNameError');
            hideError('gameCostError');
            hideError('hoursPlayedError');
            
            // Add game to array
            const game = {
                id: Date.now(), // Simple ID generation
                name: gameName,
                cost: gameCost,
                dlcCost: dlcCost,
                hoursPlayed: hoursPlayed,
                totalCost: gameCost + dlcCost,
                costPerHour: hoursPlayed > 0 ? (gameCost + dlcCost) / hoursPlayed : 0
            };
            
            games.push(game);
            
            // Clear inputs
            gameNameInput.value = '';
            gameCostInput.value = '';
            dlcCostInput.value = '';
            hoursPlayedInput.value = '';
            
            // Update UI
            updateGamesList();
            updateCalculateButtonState();
            // Section is always visible now (contains add game form)
        }
        
        function removeGame(gameId) {
            games = games.filter(game => game.id !== gameId);
            updateGamesList();
            updateCalculateButtonState();
            
            if (games.length === 0) {
                // Games section stays visible (contains add game form)
                verdictCard.style.display = 'none';
                resultsCard.style.display = 'none';
            }
        }
        
        function updateGamesList() {
            gamesListContent.innerHTML = '';
            games.forEach(game => {
                const gameItem = document.createElement('div');
                gameItem.className = 'game-item';
                
                const steamBadge = game.fromSteam ? '<span class="steam-badge">üéÆ Steam</span>' : '';
                const priceInputClass = game.totalCost === 0 ? 'needs-value' : '';
                const hoursInputClass = game.hoursPlayed === 0 ? 'needs-value' : '';
                
                gameItem.innerHTML = `
                    <div class="game-info">
                        <div class="game-name">
                            <span>${game.name}</span>
                            ${steamBadge}
                        </div>
                        <div class="game-details">
                            ${game.totalCost > 0 ? `$${game.costPerHour.toFixed(2)}/hr` : 'Add price to calculate'}
                        </div>
                    </div>
                    <div class="game-editable-field">
                        <label for="price-${game.id}">Price ($)</label>
                        <input type="number" 
                               id="price-${game.id}" 
                               class="${priceInputClass}"
                               value="${game.totalCost > 0 ? game.totalCost : ''}" 
                               placeholder="0.00"
                               min="0" 
                               step="0.01"
                               onchange="updateGamePrice(${game.id}, this.value)">
                    </div>
                    <div class="game-editable-field">
                        <label for="hours-${game.id}">Hours</label>
                        <input type="number" 
                               id="hours-${game.id}" 
                               class="${hoursInputClass}"
                               value="${game.hoursPlayed > 0 ? game.hoursPlayed : ''}" 
                               placeholder="0"
                               min="0" 
                               step="0.1"
                               onchange="updateGameHours(${game.id}, this.value)">
                    </div>
                    <div class="game-actions">
                        <button class="remove-game-btn" onclick="removeGame(${game.id})">Remove</button>
                    </div>
                `;
                gamesListContent.appendChild(gameItem);
            });
            // Ensure scroll height shows ~10 rows
            applyScrollableHeights();
        }

        // Steam API functions
        async function connectSteam() {
            const steamId = steamIdInput.value.trim();
            if (!steamId) {
                showSteamStatus('error', 'Please enter a Steam ID or profile URL');
                return;
            }

            showSteamStatus('loading', 'Connecting to Steam...');
            steamConnectBtn.disabled = true;
            steamConnectBtn.textContent = 'Connecting...';

            try {
                // Parse Steam ID from various formats
                const parsedSteamId = parseSteamId(steamId);
                if (!parsedSteamId) {
                    throw new Error('Invalid Steam ID format. Please use a Steam ID or profile URL.');
                }

                // Get owned games
                const ownedGames = await getOwnedGames(parsedSteamId);
                
                if (ownedGames.length === 0) {
                    showSteamStatus('error', 'No games found in your Steam library or profile is private.');
                    return;
                }

                // Import games (with fetched prices)
                const result = await importSteamGames(ownedGames);
                
                showSteamStatus('success', `Successfully imported ${result.importedCount} games from Steam!${result.limitNote}`);
                
                // Update games list UI
                updateGamesList();
                updateCalculateButtonState();

            } catch (error) {
                console.error('Steam API Error:', error);
                showSteamStatus('error', `Failed to connect to Steam: ${error.message}`);
            } finally {
                steamConnectBtn.disabled = false;
                steamConnectBtn.textContent = 'Connect Steam';
            }
        }

        function parseSteamId(input) {
            // Handle different Steam ID formats
            if (/^\d{17}$/.test(input)) {
                // Direct Steam ID (64-bit)
                return input;
            } else if (/steamcommunity\.com\/profiles\/(\d{17})/.test(input)) {
                // Steam profile URL with numeric ID (handles trailing slashes and query params)
                const match = input.match(/steamcommunity\.com\/profiles\/(\d{17})/);
                return match[1];
            } else if (/steamcommunity\.com\/id\/([^\/\?]+)/.test(input)) {
                // Steam profile URL with custom ID (handles trailing slashes and query params)
                const match = input.match(/steamcommunity\.com\/id\/([^\/\?]+)/);
                return match[1];
            } else if (/^[a-zA-Z0-9_-]+$/.test(input)) {
                // Custom Steam ID
                return input;
            }
            return null;
        }

        async function getOwnedGames(steamId) {
            // First, resolve custom Steam ID to numeric ID if needed
            let numericSteamId = steamId;
            if (!/^\d{17}$/.test(steamId)) {
                numericSteamId = await resolveSteamId(steamId);
                if (!numericSteamId) {
                    throw new Error('Could not resolve Steam ID');
                }
            }

            // Get owned games using CORS proxy
            const apiUrl = `${STEAM_API_BASE}/IPlayerService/GetOwnedGames/v0001/?key=${STEAM_API_KEY}&steamid=${numericSteamId}&format=json&include_appinfo=true`;
            const url = `${CORS_PROXY}${encodeURIComponent(apiUrl)}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Steam API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.response.games || [];
        }

        async function resolveSteamId(customId) {
            // Use CORS proxy for resolving custom Steam IDs
            const apiUrl = `${STEAM_API_BASE}/ISteamUser/ResolveVanityURL/v0001/?key=${STEAM_API_KEY}&vanityurl=${customId}`;
            const url = `${CORS_PROXY}${encodeURIComponent(apiUrl)}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Steam API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.response.steamid || null;
        }

        async function importSteamGames(ownedGames) {
            let importedCount = 0;
            let skippedCount = 0;
            
            // Limit to 100 games to prevent overwhelming the API and UI
            const gamesToImport = ownedGames.slice(0, 200);
            const totalGames = gamesToImport.length;
            
            // Show initial progress message
            showSteamStatus('loading', `Importing ${totalGames} games and fetching prices... 0%`);
            
            for (let i = 0; i < totalGames; i++) {
                const game = gamesToImport[i];
                
                // Skip hidden games (Steam API usually doesn't return these, but double-check)
                // Games marked as hidden or private won't have certain properties
                if (game.has_community_visible_stats === false || !game.name) {
                    skippedCount++;
                    continue;
                }
                
                // Convert playtime from minutes to hours (keep 0 hour games)
                const hoursPlayed = game.playtime_forever ? Math.round((game.playtime_forever / 60) * 10) / 10 : 0; // Round to 1 decimal
                
                // Check if game already exists
                const existingGame = games.find(g => g.name === game.name);
                if (existingGame) {
                    // Update hours played if Steam has more accurate data
                    if (hoursPlayed > existingGame.hoursPlayed) {
                        existingGame.hoursPlayed = hoursPlayed;
                        existingGame.costPerHour = existingGame.totalCost > 0 && hoursPlayed > 0 ? existingGame.totalCost / hoursPlayed : 0;
                    }
                    skippedCount++;
                    continue;
                }
                
                // Fetch price from Steam Store API
                let gamePrice = 0;
                try {
                    gamePrice = await fetchGamePrice(game.appid);
                    // Small delay to avoid rate limiting and show progress
                    await new Promise(resolve => setTimeout(resolve, 200));
                } catch (error) {
                    console.warn(`Could not fetch price for ${game.name}:`, error);
                }
                
                // Add new game with price
                const newGame = {
                    id: Date.now() + importedCount, // Simple ID generation
                    name: game.name,
                    cost: gamePrice,
                    dlcCost: 0,
                    hoursPlayed: hoursPlayed,
                    totalCost: gamePrice,
                    costPerHour: gamePrice > 0 && hoursPlayed > 0 ? gamePrice / hoursPlayed : 0,
                    fromSteam: true, // Flag to indicate this came from Steam
                    appId: game.appid, // Store Steam app ID for reference
                    iconUrl: game.img_icon_url ? `https://media.steampowered.com/steamcommunity/public/images/apps/${game.appid}/${game.img_icon_url}.jpg` : null
                };
                
                games.push(newGame);
                importedCount++;
                
                // Update progress percentage
                const progress = Math.round(((i + 1) / totalGames) * 100);
                showSteamStatus('loading', `Importing ${totalGames} games and fetching prices... ${progress}%`);
            }
            
            console.log(`Imported ${importedCount} games, skipped ${skippedCount} games (hidden or duplicates)`);
            
            // Show note if user had more than 200 games
            if (ownedGames.length > 100) {
                const limitNote = ` (Limited to first 200 games from your ${ownedGames.length} game library)`;
                return { importedCount, limitNote };
            }
            
            return { importedCount, limitNote: '' };
        }

        async function fetchGamePrice(appId) {
            try {
                const apiUrl = `https://store.steampowered.com/api/appdetails?appids=${appId}&filters=price_overview&cc=US`;
                const url = `${CORS_PROXY}${encodeURIComponent(apiUrl)}`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    return 0;
                }
                
                const data = await response.json();
                
                // Check if the API returned valid data
                if (data[appId] && data[appId].success && data[appId].data) {
                    const priceData = data[appId].data.price_overview;
                    if (priceData && priceData.initial) {
                        // Steam API returns price in cents, convert to dollars
                        return priceData.initial / 100;
                    }
                }
                
                return 0; // Free game or price not available
            } catch (error) {
                console.warn(`Error fetching price for app ${appId}:`, error);
                return 0;
            }
        }

        function showSteamStatus(type, message) {
            steamStatus.className = `steam-status ${type}`;
            steamStatus.textContent = message;
            steamStatus.style.display = 'block';
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    steamStatus.style.display = 'none';
                }, 5000);
            }
        }

        function updateGamePrice(gameId, newPrice) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;
            
            const price = parseFloat(newPrice);
            if (isNaN(price) || price < 0) {
                // Reset to previous value if invalid
                document.getElementById(`price-${gameId}`).value = game.totalCost > 0 ? game.totalCost : '';
                return;
            }
            
            // Update game with new price
            game.cost = price;
            game.totalCost = price;
            game.costPerHour = price > 0 && game.hoursPlayed > 0 ? price / game.hoursPlayed : 0;
            
            // Update UI to reflect changes
            updateGamesList();
        }

        function updateGameHours(gameId, newHours) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;
            
            const hours = parseFloat(newHours);
            if (isNaN(hours) || hours < 0) {
                // Reset to previous value if invalid
                document.getElementById(`hours-${gameId}`).value = game.hoursPlayed > 0 ? game.hoursPlayed : '';
                return;
            }
            
            // Update game with new hours
            game.hoursPlayed = hours;
            game.costPerHour = game.totalCost > 0 && hours > 0 ? game.totalCost / hours : 0;
            
            // Update UI to reflect changes
            updateGamesList();
        }


        function showError(errorId, message) {
            const errorEl = document.getElementById(errorId);
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            errorEl.previousElementSibling.classList.add('error');
        }

        function hideError(errorId) {
            const errorEl = document.getElementById(errorId);
            errorEl.style.display = 'none';
            errorEl.previousElementSibling.classList.remove('error');
        }

        function calculateROI() {
            if (games.length === 0) {
                alert('Please add at least one game before calculating.');
                return;
            }
            
            // Remove shiny animation from calculate button
            calculateBtn.classList.remove('shiny');
            
            // Animate card movement
            const inputCard = document.getElementById('inputCard');
            const advancedCard = document.querySelector('.shared-card:last-of-type'); // Advanced Assumptions card
            
            if (inputCard && advancedCard && advancedCard.parentNode) {
                // Add slide-up animation class
                inputCard.classList.add('card-slide-up');
                
                // Wait for animation to complete, then move the card
                setTimeout(() => {
                    advancedCard.parentNode.insertBefore(inputCard, advancedCard);
                    inputCard.classList.remove('card-slide-up');
                    inputCard.classList.add('card-slide-in');
                    
                    // Remove animation class after completion
                    setTimeout(() => {
                        inputCard.classList.remove('card-slide-in');
                    }, 600);
                }, 400);
            }
            
            // Collapse games list when calculating
            if (gamesList.style.display !== 'none') {
                gamesList.style.display = 'none';
                gamesListToggle.textContent = '‚ñ∂';
            }
            
            // Calculate aggregate metrics
            const totalCost = games.reduce((sum, game) => sum + game.totalCost, 0);
            const totalHours = games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const aggregateCostPerHour = totalHours > 0 ? totalCost / totalHours : 0;
            const neverPlayedCost = games.reduce((sum, game) => game.hoursPlayed === 0 ? sum + game.totalCost : sum, 0);
            
            // Update results display
            updateResults(aggregateCostPerHour, neverPlayedCost, totalHours, totalCost);
            
            // Generate verdict
            generateVerdict(aggregateCostPerHour);
            
            // Update charts
            updateSpendPieChart(neverPlayedCost, totalCost);
            updateScatterChart();
            updateComparisonChart();
            
            // Show results
            verdictCard.style.display = 'block';
            resultsCard.style.display = 'block';
            individualGamesSection.style.display = 'block';
            updateIndividualGamesMetrics();
        }

        function updateResults(costPerHour, neverPlayedCost, totalGamingHours, totalCost) {
            // Update cost per hour with color coding
            aggregateCostPerHourEl.textContent = `$${costPerHour.toFixed(2)}/hr`;
            aggregateCostPerHourEl.className = 'value ' + getCostPerHourColorClass(costPerHour);
            
            // Update total gaming hours
            const totalGamingHoursEl = document.getElementById('totalGamingHours');
            totalGamingHoursEl.textContent = totalGamingHours.toLocaleString('en-US', { maximumFractionDigits: 1 });
            totalGamingHoursEl.className = 'value';
            
            // Update total cost of gaming
            const totalCostOfGamingEl = document.getElementById('totalCostOfGaming');
            totalCostOfGamingEl.textContent = `$${totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            totalCostOfGamingEl.className = 'value';
            
            // Update never-played cost with conditional red color coding
            neverPlayedCostEl.textContent = `$${neverPlayedCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            // Color code red if never-played cost > half of total cost
            if (neverPlayedCost > (totalCost / 2)) {
                neverPlayedCostEl.className = 'value yikes'; // Red
            } else {
                neverPlayedCostEl.className = 'value';
            }
        }

        function getCostPerHourColorClass(costPerHour) {
            if (costPerHour <= 1.00) return 'legendary';
            if (costPerHour <= 3.00) return 'elite';
            if (costPerHour <= 8.00) return 'solid';
            if (costPerHour <= 15.00) return 'reasonable';
            if (costPerHour <= 30.00) return 'premium';
            return 'yikes';
        }

        function getHoursOfWorkColorClass(hoursOfWork) {
            if (hoursOfWork <= 1) return 'legendary';
            if (hoursOfWork <= 3) return 'elite';
            if (hoursOfWork <= 8) return 'solid';
            if (hoursOfWork <= 15) return 'reasonable';
            if (hoursOfWork <= 30) return 'premium';
            return 'yikes';
        }
        
        // Global sort state for table
        let currentSortColumn = null;
        let currentSortDirection = 'asc';

        function updateIndividualGamesMetrics() {
            gamesMetrics.innerHTML = '';
            
            const table = document.createElement('table');
            table.className = 'games-table';
            
            // Create table header with sortable columns
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = `
                <th class="sortable" data-column="name">Game</th>
                <th class="sortable cost-per-hour" data-column="totalCost">Initial Cost</th>
                <th class="sortable hours-work" data-column="hoursPlayed">Total Hours</th>
                <th class="sortable cost-per-hour" data-column="costPerHour">Cost per Hour</th>
            `;
            table.appendChild(headerRow);
            
            // Add click handlers to sortable headers
            headerRow.querySelectorAll('th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.column;
                    if (currentSortColumn === column) {
                        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSortColumn = column;
                        currentSortDirection = 'asc';
                    }
                    updateIndividualGamesMetrics();
                });
                
                // Add sort indicators
                if (th.dataset.column === currentSortColumn) {
                    th.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
            
            // Sort games based on current column and direction
            let sortedGames = [...games];
            if (currentSortColumn) {
                sortedGames.sort((a, b) => {
                    let aVal, bVal;
                    
                    if (currentSortColumn === 'name') {
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                        return currentSortDirection === 'asc' 
                            ? aVal.localeCompare(bVal) 
                            : bVal.localeCompare(aVal);
                    } else if (currentSortColumn === 'hoursOfWork') {
                        aVal = hourlyIncome && hourlyIncome > 0 ? a.totalCost / hourlyIncome : 0;
                        bVal = hourlyIncome && hourlyIncome > 0 ? b.totalCost / hourlyIncome : 0;
                    } else {
                        aVal = a[currentSortColumn] || 0;
                        bVal = b[currentSortColumn] || 0;
                    }
                    
                    return currentSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                });
            }
            
            // Create table rows for each game
            sortedGames.forEach(game => {
                const costPerHourClass = getCostPerHourColorClass(game.costPerHour);
                
                // Add game icon if available
                const gameIcon = game.iconUrl ? `<img src="${game.iconUrl}" alt="${game.name}" class="game-icon" onerror="this.style.display='none'">` : '';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="game-name">
                        ${gameIcon}
                        <span>${game.name}</span>
                    </td>
                    <td class="cost-per-hour">
                        <span class="metric-value">$${game.totalCost.toFixed(2)}</span>
                    </td>
                    <td class="hours-work">
                        <span class="metric-value">${game.hoursPlayed.toFixed(1)}</span>
                    </td>
                    <td class="cost-per-hour">
                        <span class="metric-value metric-${costPerHourClass}">$${game.costPerHour.toFixed(2)}/hr</span>
                    </td>
                `;
                table.appendChild(row);
            });
            
            gamesMetrics.appendChild(table);
            // Ensure scroll height shows header + ~10 data rows
            applyScrollableHeights();
        }

        function generateVerdict(costPerHour) {
            let verdict;
            
            // Verdict based on cost per hour - more generous thresholds
            if (costPerHour <= 1.00) {
                verdict = "Legendary ROI. You basically got paid to have fun.";
            } else if (costPerHour <= 3.00) {
                verdict = "Elite value. Beats most entertainment options per hour.";
            } else if (costPerHour <= 8.00) {
                verdict = "Solid deal. Competitive with premium entertainment.";
            } else if (costPerHour <= 15.00) {
                verdict = "Reasonable. Still cheaper than a concert or sports ticket.";
            } else if (costPerHour <= 30.00) {
                verdict = "Premium pricing. You're paying for the experience.";
            } else {
                verdict = "Yikes. You funded a CEO yacht per hour.";
            }
            
            verdictTextEl.textContent = verdict;
            verdictSubtextEl.textContent = ''; // Clear subtext since we removed income-based punchlines
        }

        function updateSpendPieChart(neverPlayedCost, totalCost) {
            const ctx = document.getElementById('spendPieChart').getContext('2d');
            if (spendPieChart) {
                spendPieChart.destroy();
            }
            
            const playedCost = totalCost - neverPlayedCost;
            
            spendPieChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: ['Games Played', 'Games Never Played'],
                    datasets: [{
                        data: [playedCost, neverPlayedCost],
                        backgroundColor: [
                            'rgba(76, 175, 80, 0.7)',  // Green for played games
                            'rgba(244, 67, 54, 0.7)'   // Red for never played
                        ],
                        borderColor: [
                            'rgba(76, 175, 80, 1)',
                            'rgba(244, 67, 54, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                font: {
                                    family: 'Yu Gothic UI, sans-serif',
                                    size: 14
                                },
                                color: '#2c5aa0',
                                padding: 15,
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            titleColor: '#2c5aa0',
                            bodyColor: '#2c5aa0',
                            borderColor: '#2c5aa0',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const percentage = ((value / totalCost) * 100).toFixed(1);
                                    return `${label}: $${value.toFixed(2)} (${percentage}%)`;
                                }
                            }
                        },
                        datalabels: {
                            color: '#fff',
                            font: {
                                family: 'Yu Gothic UI, sans-serif',
                                size: 16,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const percentage = ((value / totalCost) * 100).toFixed(1);
                                return '$' + value.toFixed(2) + '\n(' + percentage + '%)';
                            },
                            textAlign: 'center'
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function updateScatterChart() {
            const ctx = document.getElementById('scatterChart').getContext('2d');
            if (scatterChart) {
                scatterChart.destroy();
            }
            
            // Configuration: Hours cap for outlier detection
            const H_CAP = 200;
            
            // Compute effectiveHours and CPH for each game
            const computedData = games.map(game => {
                const isNeverPlayed = game.hoursPlayed === 0;
                // Check outlier status BEFORE applying effectiveHours logic
                const isOutlier = !isNeverPlayed && game.hoursPlayed > H_CAP;
                
                // Calculate effectiveHours for CPH calculation
                let effectiveHours;
                if (isNeverPlayed) {
                    effectiveHours = 0.1;  // Never-played games
                } else if (isOutlier) {
                    effectiveHours = game.hoursPlayed;  // Use true hours for CPH calculation
                } else {
                    effectiveHours = Math.max(game.hoursPlayed, 0.5);  // Normal games
                }
                
                const cph = game.totalCost / effectiveHours;
                const plotHours = isOutlier ? H_CAP : effectiveHours;
                
                return {
                    name: game.name,
                    effectiveHours: effectiveHours,
                    plotHours: plotHours,
                    cph: cph,
                    costUsd: game.totalCost,
                    hoursPlayed: game.hoursPlayed,
                    isNeverPlayed: isNeverPlayed,
                    isOutlier: isOutlier,
                    iconUrl: game.iconUrl
                };
            });
            
            // Split data into main points and outliers
            const mainPoints = computedData.filter(d => !d.isOutlier);
            const outlierPoints = computedData.filter(d => d.isOutlier);
            
            // Debug logging
            console.log(`Total games: ${computedData.length}, Main: ${mainPoints.length}, Outliers: ${outlierPoints.length}`);
            console.log('All computed data:', computedData.map(d => `${d.name}: ${d.hoursPlayed}h, isOutlier: ${d.isOutlier}`));
            if (outlierPoints.length > 0) {
                console.log('Outlier games (>200h):', outlierPoints.map(d => `${d.name}: ${d.hoursPlayed}h ‚Üí plotted at ${d.plotHours}h, CPH: $${d.cph.toFixed(2)}`));
            }
            
            // Compute medians on main points only (for quadrant division)
            const mainHoursSorted = mainPoints.map(d => d.plotHours).sort((a, b) => a - b);
            const mainCphSorted = mainPoints.map(d => d.cph).sort((a, b) => a - b);
            
            const medianHours = mainHoursSorted.length > 0
                ? (mainHoursSorted.length % 2 === 0
                    ? (mainHoursSorted[mainHoursSorted.length / 2 - 1] + mainHoursSorted[mainHoursSorted.length / 2]) / 2
                    : mainHoursSorted[Math.floor(mainHoursSorted.length / 2)])
                : H_CAP / 2;
            
            const medianCph = mainCphSorted.length > 0
                ? (mainCphSorted.length % 2 === 0
                    ? (mainCphSorted[mainCphSorted.length / 2 - 1] + mainCphSorted[mainCphSorted.length / 2]) / 2
                    : mainCphSorted[Math.floor(mainCphSorted.length / 2)])
                : 1;
            
            // Assign quadrant and color based on plot position
            const getQuadrant = (plotHours, cph) => {
                const isLeft = plotHours <= medianHours;
                const isTop = cph >= medianCph;
                if (isLeft && isTop) return { label: 'Backlog shame', color: 'rgba(244, 67, 54, 0.7)' }; // Red
                if (!isLeft && isTop) return { label: 'Luxury hobby', color: 'rgba(255, 152, 0, 0.7)' }; // Orange
                if (isLeft && !isTop) return { label: 'Casual win', color: 'rgba(33, 150, 243, 0.7)' }; // Blue
                return { label: 'Evergreen value', color: 'rgba(76, 175, 80, 0.7)' }; // Green
            };
            
            // Create main dataset
            const mainDataset = mainPoints.map(d => {
                const quad = getQuadrant(d.plotHours, d.cph);
                const radius = 16;
                
                return {
                    x: d.plotHours,
                    y: d.cph,
                    label: d.name,
                    costUsd: d.costUsd,
                    hoursPlayed: d.hoursPlayed,
                    effectiveHours: d.effectiveHours,
                    cph: d.cph,
                    isNeverPlayed: d.isNeverPlayed,
                    isOutlier: false,
                    quadrant: quad.label,
                    borderColor: d.isNeverPlayed ? 'rgba(150, 0, 0, 1)' : quad.color,
                    borderWidth: d.isNeverPlayed ? 3 : 2,
                    iconUrl: d.iconUrl
                };
            });
            
            // Create outlier dataset
            const outlierDataset = outlierPoints.map(d => {
                const quad = getQuadrant(d.plotHours, d.cph);
                const radius = 16;
                
                return {
                    x: d.plotHours,
                    y: d.cph,
                    label: d.name,
                    costUsd: d.costUsd,
                    hoursPlayed: d.hoursPlayed,
                    effectiveHours: d.effectiveHours,
                    cph: d.cph,
                    isNeverPlayed: false,
                    isOutlier: true,
                    quadrant: quad.label,
                    borderColor: quad.color,
                    borderWidth: 3,
                    iconUrl: d.iconUrl
                };
            });
            
            // Calculate axis ranges using logarithmic scale
            const allPoints = [...mainDataset, ...outlierDataset];
            const xValues = allPoints.map(d => d.x).filter(x => x > 0);
            const yValues = allPoints.map(d => d.y).filter(y => y > 0);
            
            const xMin = 0.05;  // Log scale min
            const xMax = H_CAP * 1.2;  // Slightly beyond cap
            const yMin = Math.min(...yValues) * 0.5;  // Dynamic min with padding below lowest point
            const yMax = Math.max(...yValues) * 2;  // Dynamic max with padding
            
            // Create icon images for both datasets
            const mainIcons = mainDataset.map(d => {
                if (d.iconUrl) {
                    const img = new Image(32, 32);
                    img.src = d.iconUrl;
                    img.onload = () => {
                        if (scatterChart) scatterChart.update('none');
                    };
                    return img;
                }
                return d.isNeverPlayed ? 'triangle' : 'circle';
            });
            
            const outlierIcons = outlierDataset.map((d, idx) => {
                if (d.iconUrl) {
                    const img = new Image(32, 32);
                    img.src = d.iconUrl;
                    console.log(`Loading outlier icon ${idx}: ${d.label} from ${d.iconUrl}`);
                    img.onload = () => {
                        console.log(`Outlier icon ${idx} loaded: ${d.label}`);
                        if (scatterChart) scatterChart.update('none');
                    };
                    return img;
                }
                return 'circle';
            });
            
            console.log('Outlier dataset:', outlierDataset.map(d => `${d.label}: x=${d.x}, y=${d.y.toFixed(2)}`));
            
            // Chart.js scatter with log scales and two datasets
            scatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        // Main points dataset
                        {
                            label: 'Games',
                            data: mainDataset,
                            pointStyle: 'circle',
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            borderWidth: 0,
                            pointRadius: 16,
                            pointHoverRadius: 20
                        },
                        // Outliers dataset (200h+ capped)
                        {
                            label: '200h+ capped',
                            data: outlierDataset,
                            pointStyle: 'circle',
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            borderWidth: 0,
                            pointRadius: 16,
                            pointHoverRadius: 20,
                            borderDash: [5, 5]  // Dashed for distinction
                        }
                    ]
                },
                plugins: [{
                    id: 'circularIcons',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        
                        // Draw main dataset (dataset 0)
                        const mainMeta = chart.getDatasetMeta(0);
                        mainMeta.data.forEach((point, index) => {
                            const d = mainDataset[index];
                            const img = mainIcons[index];
                            const x = point.x;
                            const y = point.y;
                            const radius = point.options.radius || 16;
                            
                            if (img instanceof Image && img.complete) {
                                // Draw circular clipped image (no border)
                                ctx.save();
                                ctx.beginPath();
                                ctx.arc(x, y, radius, 0, Math.PI * 2);
                                ctx.closePath();
                                ctx.clip();
                                ctx.drawImage(img, x - radius, y - radius, radius * 2, radius * 2);
                                ctx.restore();
                            } else {
                                // Draw shape for never-played or no-icon games
                                ctx.beginPath();
                                if (d.isNeverPlayed) {
                                    // Triangle for never-played
                                    ctx.moveTo(x, y - radius);
                                    ctx.lineTo(x + radius, y + radius);
                                    ctx.lineTo(x - radius, y + radius);
                                    ctx.closePath();
                                } else {
                                    // Circle
                                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                                }
                                ctx.fillStyle = d.borderColor; // Use the color but no border
                                ctx.fill();
                            }
                        });
                        
                        // Draw outlier dataset (dataset 1) with dashed borders
                        if (chart.data.datasets.length > 1) {
                            const outlierMeta = chart.getDatasetMeta(1);
                            console.log('Outlier meta points:', outlierMeta.data.length, 'Expected:', outlierDataset.length);
                            outlierMeta.data.forEach((point, index) => {
                                const d = outlierDataset[index];
                                const img = outlierIcons[index];
                                const x = point.x;
                                const y = point.y;
                                const radius = point.options.radius || 16;
                                console.log(`Drawing outlier ${index}: ${d.label} at (${x}, ${y}), img loaded:`, img instanceof Image && img.complete);
                                
                                if (img instanceof Image && img.complete) {
                                    // Draw circular clipped image (no border)
                                    ctx.save();
                                    ctx.beginPath();
                                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                                    ctx.closePath();
                                    ctx.clip();
                                    ctx.drawImage(img, x - radius, y - radius, radius * 2, radius * 2);
                                    ctx.restore();
                                } else {
                                    // Draw circle without border
                                    ctx.beginPath();
                                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                                    ctx.fillStyle = d.borderColor; // Use the color but no border
                                    ctx.fill();
                                }
                            });
                        }
                    }
                }],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { 
                        mode: 'point', 
                        intersect: true,
                        includeInvisible: false
                    },
                    plugins: {
                        title: {
                            display: false  // Title moved to HTML element above chart
                        },
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            displayColors: false,
                            callbacks: {
                                title: (ctx) => ctx[0]?.raw?.label || 'Unknown',
                                label: (ctx) => {
                                    const d = ctx.raw;
                                    const lines = [
                                        `Hours played: ${d.hoursPlayed.toFixed(1)}`,  // True hours
                                        `Total cost: $${d.costUsd.toFixed(2)}`,
                                        `Cost per hour: $${d.cph.toFixed(2)}`
                                    ];
                                    if (d.isNeverPlayed) {
                                        lines.push('Status: Never played');
                                    }
                                    if (d.isOutlier) {
                                        lines.push(`Note: Plotted at ${H_CAP}h cap (actual: ${d.hoursPlayed.toFixed(1)}h)`);
                                    }
                                    return lines;
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                medianVLine: {
                                    type: 'line',
                                    xMin: medianHours,
                                    xMax: medianHours,
                                    borderColor: 'rgba(100, 100, 100, 0.3)',
                                    borderWidth: 2,
                                    borderDash: [3, 3]
                                },
                                medianHLine: {
                                    type: 'line',
                                    yMin: medianCph,
                                    yMax: medianCph,
                                    borderColor: 'rgba(100, 100, 100, 0.3)',
                                    borderWidth: 2,
                                    borderDash: [3, 3]
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            min: xMin,
                            max: xMax,
                            title: {
                                display: true,
                                text: 'Hours Played (log scale)',
                                font: { family: 'Lucida Console, Monaco, Courier New, monospace', size: 12 },
                                color: '#2c5aa0',
                                padding: { top: 10 }
                            },
                            ticks: {
                                display: false  // Hide tick labels
                            },
                            grid: { 
                                display: false,
                                drawBorder: false  // Hide axis line
                            },
                            border: {
                                display: false  // Hide border
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            min: yMin,
                            max: yMax,
                            title: {
                                display: true,
                                text: 'Cost per Hour ($/hr, log scale)',
                                font: { family: 'Lucida Console, Monaco, Courier New, monospace', size: 12 },
                                color: '#2c5aa0',
                                padding: { right: 10 }
                            },
                            ticks: {
                                display: false  // Hide tick labels
                            },
                            grid: { 
                                display: false,
                                drawBorder: false  // Hide axis line
                            },
                            border: {
                                display: false  // Hide border
                            }
                        }
                    }
                }
            });
        }

        function updateComparisonChart() {
            if (games.length === 0) return;
            
            // Calculate aggregate cost per hour
            const totalCost = games.reduce((sum, game) => sum + game.totalCost, 0);
            const totalHours = games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const aggregateCostPerHour = totalHours > 0 ? totalCost / totalHours : 0;
            
            // Get assumption values
            const assumptions = {
                movie: parseFloat(document.getElementById('moviePrice').value) / parseFloat(document.getElementById('movieHours').value),
                disney: parseFloat(document.getElementById('disneyPrice').value) / parseFloat(document.getElementById('disneyHours').value),
                concert: parseFloat(document.getElementById('concertPrice').value) / parseFloat(document.getElementById('concertHours').value),
                basketball: parseFloat(document.getElementById('basketballPrice').value) / parseFloat(document.getElementById('basketballHours').value),
                netflix: parseFloat(document.getElementById('netflixPrice').value) / parseFloat(document.getElementById('netflixHours').value),
                max: parseFloat(document.getElementById('maxPrice').value) / parseFloat(document.getElementById('maxHours').value),
                youtube: parseFloat(document.getElementById('youtubePrice').value) / parseFloat(document.getElementById('youtubeHours').value),
                gym: parseFloat(document.getElementById('gymPrice').value) / parseFloat(document.getElementById('gymHours').value),
                spotify: parseFloat(document.getElementById('spotifyPrice').value) / parseFloat(document.getElementById('spotifyHours').value)
            };
            
            // Create array of all entertainment options with their data
            const entertainmentOptions = [
                { label: 'Your Gaming Collection', value: aggregateCostPerHour, isUserGame: true },
                { label: 'Movie Ticket', value: assumptions.movie, isUserGame: false },
                { label: 'Disneyland', value: assumptions.disney, isUserGame: false },
                { label: 'Concert Ticket', value: assumptions.concert, isUserGame: false },
                { label: 'Basketball Ticket', value: assumptions.basketball, isUserGame: false },
                { label: 'Netflix', value: assumptions.netflix, isUserGame: false },
                { label: 'Max', value: assumptions.max, isUserGame: false },
                { label: 'YouTube Premium', value: assumptions.youtube, isUserGame: false },
                { label: 'Gym Membership', value: assumptions.gym, isUserGame: false },
                { label: 'Spotify Premium', value: assumptions.spotify, isUserGame: false }
            ];
            
            // Sort by cost per hour in descending order (highest to lowest)
            entertainmentOptions.sort((a, b) => b.value - a.value);
            
            // Extract sorted data for chart
            const sortedLabels = entertainmentOptions.map(option => option.label);
            const sortedData = entertainmentOptions.map(option => option.value);
            const sortedBackgroundColors = entertainmentOptions.map(option => 
                option.isUserGame ? 'rgba(74, 144, 226, 0.8)' : 'rgba(126, 211, 33, 0.6)'
            );
            const sortedBorderColors = entertainmentOptions.map(option => 
                option.isUserGame ? 'rgba(74, 144, 226, 1)' : 'rgba(126, 211, 33, 1)'
            );
            
            const chartData = {
                labels: sortedLabels,
                datasets: [{
                    label: 'Cost per Hour ($)',
                    data: sortedData,
                    backgroundColor: sortedBackgroundColors,
                    borderColor: sortedBorderColors,
                    borderWidth: 2
                }]
            };
            
            const chartConfig = {
                type: 'bar',
                data: chartData,
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Cost per hour ($)',
                                font: {
                                    family: 'Lucida Console, Monaco, Courier New, monospace'
                                },
                                color: '#2c5aa0'
                            },
                            grid: {
                                color: 'rgba(74, 144, 226, 0.2)'
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(74, 144, 226, 0.2)'
                            }
                        }
                    }
                }
            };
            
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            if (comparisonChart) {
                comparisonChart.destroy();
            }
            comparisonChart = new Chart(ctx, chartConfig);
        }

        function toggleAccordion() {
            const isExpanded = accordionContent.classList.contains('expanded');
            if (isExpanded) {
                accordionContent.classList.remove('expanded');
                accordionToggle.textContent = '‚ñº';
            } else {
                accordionContent.classList.add('expanded');
                accordionToggle.textContent = '‚ñ≤';
            }
        }
        
        function toggleGamesList() {
            if (gamesList.style.display === 'none') {
                gamesList.style.display = 'flex';
                gamesListToggle.textContent = '‚ñº';
            } else {
                gamesList.style.display = 'none';
                gamesListToggle.textContent = '‚ñ∂';
            }
        }

        // Dynamically size scroll panes to show ~10 items
        function applyScrollableHeights() {
            try {
                // Games list: measure first .game-item
                const listPane = document.getElementById('gamesListContent');
                if (listPane) {
                    const firstItem = listPane.querySelector('.game-item');
                    if (firstItem) {
                        const itemH = firstItem.offsetHeight || 56; // fallback
                        listPane.style.maxHeight = (itemH * 10) + 'px';
                        listPane.style.overflowY = 'auto';
                    }
                }
                // Metrics table: include header + 10 data rows
                const metricsPane = document.getElementById('gamesMetrics');
                if (metricsPane) {
                    const headerRow = metricsPane.querySelector('table tr');
                    const dataRow = metricsPane.querySelector('table tr:nth-child(2)');
                    if (headerRow && dataRow) {
                        const h = headerRow.offsetHeight || 32;
                        const r = dataRow.offsetHeight || 40;
                        metricsPane.style.maxHeight = (h + r * 10) + 'px';
                        metricsPane.style.overflowY = 'auto';
                        metricsPane.style.display = 'block';
                    }
                }
            } catch (e) {
                // no-op
            }
        }

        window.addEventListener('resize', applyScrollableHeights);

        function resetAssumptions() {
            document.getElementById('moviePrice').value = 15;
            document.getElementById('movieHours').value = 2.5;
            document.getElementById('disneyPrice').value = 160;
            document.getElementById('disneyHours').value = 12;
            document.getElementById('netflixPrice').value = 16;
            document.getElementById('netflixHours').value = 40;
            document.getElementById('maxPrice').value = 16;
            document.getElementById('maxHours').value = 25;
            document.getElementById('youtubePrice').value = 14;
            document.getElementById('youtubeHours').value = 60;
            document.getElementById('concertPrice').value = 100;
            document.getElementById('concertHours').value = 3;
            document.getElementById('basketballPrice').value = 120;
            document.getElementById('basketballHours').value = 3;
            document.getElementById('gymPrice').value = 60;
            document.getElementById('gymHours').value = 12;
            document.getElementById('spotifyPrice').value = 11;
            document.getElementById('spotifyHours').value = 60;
            
            if (resultsCard.style.display !== 'none') {
                updateChart();
            }
        }

        function copySummary() {
            if (games.length === 0) {
                alert('No games to summarize.');
                return;
            }
            
            const totalCost = games.reduce((sum, game) => sum + game.totalCost, 0);
            const totalHours = games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const aggregateCostPerHour = totalCost / totalHours;
            
            const movieCostPerHour = parseFloat(document.getElementById('moviePrice').value) / parseFloat(document.getElementById('movieHours').value);
            const netflixCostPerHour = parseFloat(document.getElementById('netflixPrice').value) / parseFloat(document.getElementById('netflixHours').value);
            
            const movieComparison = aggregateCostPerHour < movieCostPerHour ? 'better' : 'worse';
            const netflixComparison = aggregateCostPerHour < netflixCostPerHour ? 'better' : 'worse';
            
            let summary = `I spent $${totalCost.toFixed(2)} on ${games.length} game${games.length > 1 ? 's' : ''}, played ${totalHours} hours total ‚Üí $${aggregateCostPerHour.toFixed(2)}/hr. That's ${netflixComparison} than Netflix and ${movieComparison} than a movie ticket.`;
            
            // Add work hours info if income is available
            const hourlyIncome = hourlyRateRadio.checked && hourlyRateInput.value ? parseFloat(hourlyRateInput.value) : 
                                (!hourlyRateRadio.checked && annualSalaryInput.value ? parseFloat(annualSalaryInput.value) / (parseFloat(hoursWorkedInput.value) || 2080) : null);
            
            if (hourlyIncome) {
                const totalWorkHours = totalCost / hourlyIncome;
                summary += ` That's ${totalWorkHours < 10 ? totalWorkHours.toFixed(2) : totalWorkHours.toFixed(1)} hours of work to pay for it all.`;
            }
            
            navigator.clipboard.writeText(summary).then(() => {
                shareStatus.textContent = 'Copied to clipboard!';
                setTimeout(() => {
                    shareStatus.textContent = '';
                }, 2000);
            });
        }

        function updateURL() {
            const params = new URLSearchParams();
            params.set('gameCost', gameCostInput.value);
            params.set('dlcCost', dlcCostInput.value);
            params.set('hoursPlayed', hoursPlayedInput.value);
            params.set('incomeType', hourlyRateRadio.checked ? 'hourly' : 'annual');
            params.set('hourlyRate', hourlyRateInput.value);
            params.set('annualSalary', annualSalaryInput.value);
            params.set('hoursWorked', hoursWorkedInput.value);
            
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newURL);
        }

        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            if (params.has('gameCost')) {
                gameCostInput.value = params.get('gameCost');
                dlcCostInput.value = params.get('dlcCost') || '';
                hoursPlayedInput.value = params.get('hoursPlayed');
                
                const incomeType = params.get('incomeType');
                if (incomeType === 'annual') {
                    annualSalaryRadio.checked = true;
                    annualSalaryInput.value = params.get('annualSalary');
                    hoursWorkedInput.value = params.get('hoursWorked') || '2080';
                } else {
                    hourlyRateRadio.checked = true;
                    hourlyRateInput.value = params.get('hourlyRate');
                }
                
                toggleIncomeInputs();
                calculateROI();
            }
        }
    </script>

    <!-- Parallax grid effect on scroll -->
    <script>
      window.addEventListener('scroll', function() {
        const scrolled = window.pageYOffset;
        document.documentElement.style.setProperty('--scroll-y', scrolled + 'px');
      });
    </script>
</body>
</html>
