<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaming Report Card</title>
    <link rel="icon" type="image/png" href="../favicon.png">
    <link rel="stylesheet" href="../style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        /* Page-specific styles only - most styles moved to style.css */
        .games-metrics {
            margin-bottom: 25px;
        }
        
        .crosshair-arrow {
            display: none;
        }
    </style>
</head>
<body>
    <div class="shared-wrap">
        <div class="shared-card">
            <h1 class="shared-h1">Gaming Report Card</h1>
            <a href="../index.html" class="shared-btn-ghost">üè† Home</a>
        </div>

        <div class="shared-card" id="inputCard">
            <h3>Connect Steam Account</h3>
            <p class="steam-description">Connect your Steam account to automatically import your game library and hours played.</p>
            <div class="input-section">
                <div class="input-row-inline">
                    <div class="input-group flex-grow">
                        <label for="steamId">Steam Username, ID, or Profile URL</label>
                        <input type="text" id="steamId" placeholder="e.g., username or https://steamcommunity.com/id/username">
                        <div class="error-message" id="steamIdError"></div>
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button type="button" class="steam-connect-btn" id="steamConnectBtn">Connect Steam</button>
                    </div>
                </div>
                <div class="steam-status" id="steamStatus" style="display: none;"></div>
            </div>

            <button class="calculate-btn" id="calculateBtn">Calculate ROI</button>

            <div class="games-list-section" id="gamesListSection">
                <h3 class="games-list-header" id="gamesListHeader" style="cursor: pointer;">
                    Your Games <span id="gamesListToggle">‚ñº</span>
                </h3>
                <div class="games-list" id="gamesList">
                    <!-- Add Game Section (always visible in dropdown) -->
                    <div class="add-game-section">
                        <h4>Add Game Manually</h4>
                        <div class="input-row">
                            <div class="input-group">
                                <label for="gameName">Game name *</label>
                                <input type="text" id="gameName" placeholder="e.g., Elden Ring">
                                <div class="error-message" id="gameNameError"></div>
                            </div>
                            <div class="input-group">
                                <label for="gameCost">Cost of game ($) *</label>
                                <input type="number" id="gameCost" placeholder="60" min="0" step="0.01">
                                <div class="error-message" id="gameCostError"></div>
                            </div>
                            <div class="input-group">
                                <label for="dlcCost">DLC cost ($)</label>
                                <input type="number" id="dlcCost" placeholder="0" min="0" step="0.01">
                            </div>
                            <div class="input-group">
                                <label for="hoursPlayed">Hours played *</label>
                                <input type="number" id="hoursPlayed" placeholder="40" min="0" step="0.1">
                                <div class="error-message" id="hoursPlayedError"></div>
                            </div>
                            <div class="input-group">
                                <button type="button" class="add-game-btn" id="addGameBtn">Add Game</button>
                            </div>
                        </div>
                    </div>

                    <!-- Games will be listed here -->
                    <div id="gamesListContent"></div>
                </div>
            </div>
        </div>

        <div class="shared-card verdict-card" id="verdictCard" style="display: none;">
            <div class="verdict">
                <div class="verdict-text" id="verdictText">Ready to calculate!</div>
                <div class="verdict-subtext" id="verdictSubtext">Add games and calculate to see your gaming ROI verdict.</div>
            </div>
        </div>

        <div class="shared-card results" id="resultsCard">
            <div class="primary-metrics" style="grid-template-columns: repeat(3, 1fr); max-width: 1200px; margin-left: auto; margin-right: auto;">
                <div class="primary-metric">
                    <div class="value" id="totalGamesInLibrary">0</div>
                    <div class="label">Total Games In Library</div>
                </div>
                <div class="primary-metric">
                    <div class="value" id="totalGamingHours">0</div>
                    <div class="label">Total Gaming Hours</div>
                </div>
                <div class="primary-metric">
                    <div class="value" id="totalCostOfGaming" style="white-space: nowrap;">$0.00</div>
                    <div class="label">Total Cost of Gaming</div>
                </div>
            </div>
            
            <div class="primary-metrics" style="grid-template-columns: repeat(2, 1fr); max-width: 900px; margin-left: auto; margin-right: auto;">
                <div class="primary-metric">
                    <div class="value" id="aggregateCostPerHour">$0.00/hr</div>
                    <div class="label">Aggregate cost per hour of gaming</div>
                </div>
                <div class="primary-metric">
                    <div class="value" id="refundableCost">0</div>
                    <div class="label">Games you bought could have been refunded</div>
                </div>
            </div>

            <div id="gameDistribution" style="text-align: center; margin: 30px auto; max-width: 900px; display: none;">
                <p id="gameDistributionText" style="font-size: 1.2em; color: #2c5aa0; margin-bottom: 20px;"></p>
                <div id="topGamesDisplay" style="display: flex; justify-content: center; gap: 30px; flex-wrap: wrap;"></div>
            </div>

            <div class="two-chart-row">
                <div class="chart-container">
                    <h3 style="text-align: center; margin-bottom: 20px; color: #2c5aa0; font-family: 'Lucida Console', Monaco, 'Courier New', monospace;">Hours Played Distribution</h3>
                    <canvas id="spendPieChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3 style="text-align: center; margin-bottom: 20px; color: #2c5aa0; font-family: 'Lucida Console', Monaco, 'Courier New', monospace;">Cost Per Hour Comparison</h3>
                    <canvas id="comparisonChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3 style="text-align: center; margin-bottom: 20px; color: #2c5aa0; font-family: 'Lucida Console', Monaco, 'Courier New', monospace;">Gaming Efficiency: Investment vs Value</h3>
                <div class="scatter-wrapper">
                    <div class="scatter-grid"></div>
                    <canvas id="scatterChart"></canvas>
                    <div class="scatter-crosshair">
                        <div class="crosshair-h"></div>
                        <div class="crosshair-v"></div>
                        <!-- Axis labels -->
                        <div class="axis-label axis-label-horizontal">Hours Played</div>
                        <div class="axis-label axis-label-vertical">Effective Cost</div>
                        <!-- Quadrant labels -->
                        <div class="quadrant-label quadrant-tl">Backlog shame</div>
                        <div class="quadrant-label quadrant-tr">Luxury hobby</div>
                        <div class="quadrant-label quadrant-bl">Casual win</div>
                        <div class="quadrant-label quadrant-br">Evergreen value</div>
                    </div>
                </div>
            </div>

            <div class="individual-games-section" id="individualGamesSection" style="display: none;">
                <h3>Individual Game Metrics</h3>
                <div class="games-metrics" id="gamesMetrics"></div>
            </div>

            <div class="share-section">
                <button class="share-btn" id="shareBtn">Copy Summary</button>
                <span id="shareStatus"></span>
            </div>
        </div>

        <div class="shared-card">
            <div class="accordion">
                <div class="accordion-header" id="accordionHeader">
                    <h4>Advanced Assumptions</h4>
                    <span id="accordionToggle">‚ñº</span>
                </div>
                <div class="accordion-content" id="accordionContent">
                    <p>Edit these benchmark assumptions to customize your comparison chart:</p>
                    
                    <div class="assumption-item">
                        <label>Movie ticket:</label>
                        <input type="number" id="moviePrice" value="15" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="movieHours" value="2.5" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Disneyland:</label>
                        <input type="number" id="disneyPrice" value="160" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="disneyHours" value="12" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Netflix:</label>
                        <input type="number" id="netflixPrice" value="16" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="netflixHours" value="40" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>HBO Max:</label>
                        <input type="number" id="maxPrice" value="16" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="maxHours" value="25" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>YouTube Premium:</label>
                        <input type="number" id="youtubePrice" value="14" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="youtubeHours" value="60" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Concert Ticket:</label>
                        <input type="number" id="concertPrice" value="100" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="concertHours" value="3" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Basketball Ticket:</label>
                        <input type="number" id="basketballPrice" value="120" min="0" step="0.01">
                        <span>over</span>
                        <input type="number" id="basketballHours" value="3" min="0.1" step="0.1">
                        <span>hours</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Gym Membership:</label>
                        <input type="number" id="gymPrice" value="60" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="gymHours" value="12" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <div class="assumption-item">
                        <label>Spotify Premium:</label>
                        <input type="number" id="spotifyPrice" value="11" min="0" step="0.01">
                        <span>per month over</span>
                        <input type="number" id="spotifyHours" value="60" min="0.1" step="0.1">
                        <span>hours/month</span>
                    </div>
                    
                    <button class="reset-btn" id="resetBtn">Reset to Defaults</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Suppress browser extension errors that don't affect functionality
        const suppressExtensionErrors = (event) => {
            const msg = event.message || event.reason?.message || '';
            if (msg.includes('message channel closed')) {
                event.preventDefault();
                return true;
            }
        };
        
        window.addEventListener('error', suppressExtensionErrors);
        window.addEventListener('unhandledrejection', suppressExtensionErrors);
        
        // DOM elements
        const gameNameInput = document.getElementById('gameName');
        const gameCostInput = document.getElementById('gameCost');
        const dlcCostInput = document.getElementById('dlcCost');
        const hoursPlayedInput = document.getElementById('hoursPlayed');
        const addGameBtn = document.getElementById('addGameBtn');
        const gamesListSection = document.getElementById('gamesListSection');
        const gamesList = document.getElementById('gamesList');
        const gamesListContent = document.getElementById('gamesListContent');
        
        // Steam API elements
        const steamIdInput = document.getElementById('steamId');
        const steamConnectBtn = document.getElementById('steamConnectBtn');
        const steamStatus = document.getElementById('steamStatus');
        
        const calculateBtn = document.getElementById('calculateBtn');
        const verdictCard = document.getElementById('verdictCard');
        const resultsCard = document.getElementById('resultsCard');
        
        // Results elements
        const aggregateCostPerHourEl = document.getElementById('aggregateCostPerHour');
        const refundableCostEl = document.getElementById('refundableCost');
        const verdictTextEl = document.getElementById('verdictText');
        const verdictSubtextEl = document.getElementById('verdictSubtext');
        const individualGamesSection = document.getElementById('individualGamesSection');
        const gamesMetrics = document.getElementById('gamesMetrics');
        
        // Charts
        let comparisonChart = null;
        let scatterChart = null;
        let spendPieChart = null;
        
        // Data storage
        let games = [];
        let steamUserData = { personaname: '', avatarmedium: '' };
        
        // API configuration
        const STEAM_API_KEY = 'B82CDB439F57BD8533FB8A145A61E16F';
        const STEAM_API_BASE = 'https://api.steampowered.com';
        const CORS_PROXY = 'https://corsproxy.io/?';
        const H_CAP = 200; // Hours cap for scatter chart outliers
        
        // Fun loading messages that rotate
        const LOADING_MESSAGES = [
            "Calculating your digital shame...",
            "Judging your backlog...",
            "Counting your unplayed games...",
            "Discovering your buyer's remorse...",
            "Finding your most expensive mistakes...",
            "Measuring your Steam sale impulse control...",
            "Analyzing your 'I'll play it someday' collection...",
            "Evaluating your commitment issues...",
            "Tallying your gaming sins...",
            "Reviewing your digital hoarding habits...",
            "Investigating your unfinished stories...",
            "Quantifying your FOMO purchases...",
            "Assessing your wallet's pain...",
            "Examining your 'it was on sale!' defense...",
            "Processing your gaming guilt...",
            "Loading your library of good intentions..."
        ];
        
        let loadingMessageInterval = null;
        
        // Advanced assumptions
        const accordionHeader = document.getElementById('accordionHeader');
        const accordionContent = document.getElementById('accordionContent');
        const accordionToggle = document.getElementById('accordionToggle');
        const resetBtn = document.getElementById('resetBtn');
        
        // Share functionality
        const shareBtn = document.getElementById('shareBtn');
        const shareStatus = document.getElementById('shareStatus');
        
        // Games list toggle
        const gamesListHeader = document.getElementById('gamesListHeader');
        const gamesListToggle = document.getElementById('gamesListToggle');

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            setTimeout(applyScrollableHeights, 0);
        });

        function updateCalculateButtonState() {
            // Add shiny animation when games are populated
            if (games.length > 0) {
                calculateBtn.classList.add('shiny');
            } else {
                calculateBtn.classList.remove('shiny');
            }
        }

        function setupEventListeners() {
            // Game management
            addGameBtn.addEventListener('click', addGame);
            
            // Steam connection
            steamConnectBtn.addEventListener('click', connectSteam);
            steamIdInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    connectSteam();
                }
            });
            
            // Calculate button
            calculateBtn.addEventListener('click', calculateROI);
            
            // Advanced assumptions
            accordionHeader.addEventListener('click', toggleAccordion);
            resetBtn.addEventListener('click', resetAssumptions);
            
            const assumptionInputs = [
                'moviePrice', 'movieHours', 'disneyPrice', 'disneyHours',
                'concertPrice', 'concertHours', 'basketballPrice', 'basketballHours',
                'netflixPrice', 'netflixHours', 'maxPrice', 'maxHours',
                'youtubePrice', 'youtubeHours', 'gymPrice', 'gymHours',
                'spotifyPrice', 'spotifyHours'
            ];
            assumptionInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    if (resultsCard.style.display !== 'none') {
                        updateComparisonChart();
                    }
                });
            });
            
            // Share button
            shareBtn.addEventListener('click', copySummary);
            
            // Games list toggle
            gamesListHeader.addEventListener('click', toggleGamesList);
        }

        function addGame() {
            const gameName = gameNameInput.value.trim();
            const gameCost = parseFloat(gameCostInput.value);
            const dlcCost = parseFloat(dlcCostInput.value) || 0;
            const hoursPlayed = parseFloat(hoursPlayedInput.value);
            
            // Validate inputs
            if (!gameName) {
                showError('gameNameError', 'Please enter a game name');
                return;
            }
            if (isNaN(gameCost) || gameCost < 0) {
                showError('gameCostError', 'Please enter a valid game cost');
                return;
            }
            if (isNaN(hoursPlayed) || hoursPlayed < 0) {
                showError('hoursPlayedError', 'Please enter valid hours played (‚â• 0)');
                return;
            }
            
            // Clear errors
            hideError('gameNameError');
            hideError('gameCostError');
            hideError('hoursPlayedError');
            
            // Add game to array
            const game = {
                id: Date.now(), // Simple ID generation
                name: gameName,
                cost: gameCost,
                dlcCost: dlcCost,
                hoursPlayed: hoursPlayed,
                totalCost: gameCost + dlcCost,
                totalFinalCost: gameCost + dlcCost, // For manual games, assume no discount
                costPerHour: hoursPlayed > 0 ? (gameCost + dlcCost) / hoursPlayed : 0
            };
            
            games.push(game);
            
            // Clear inputs
            gameNameInput.value = '';
            gameCostInput.value = '';
            dlcCostInput.value = '';
            hoursPlayedInput.value = '';
            
            // Update UI
            updateGamesList();
            updateCalculateButtonState();
            // Section is always visible now (contains add game form)
        }
        
        function removeGame(gameId) {
            games = games.filter(game => game.id !== gameId);
            updateGamesList();
            updateCalculateButtonState();
            
            if (games.length === 0) {
                // Games section stays visible (contains add game form)
                verdictCard.style.display = 'none';
                resultsCard.style.display = 'none';
            }
        }
        
        function updateGamesList() {
            gamesListContent.innerHTML = '';
            games.forEach(game => {
                const gameItem = document.createElement('div');
                gameItem.className = 'game-item';
                
                const steamBadge = game.fromSteam ? '<span class="steam-badge">üéÆ Steam</span>' : '';
                const priceInputClass = game.totalCost === 0 ? 'needs-value' : '';
                const hoursInputClass = game.hoursPlayed === 0 ? 'needs-value' : '';
                
                gameItem.innerHTML = `
                    <div class="game-info">
                        <div class="game-name">
                            <span>${game.name}</span>
                            ${steamBadge}
                        </div>
                        <div class="game-details">
                            ${game.totalCost > 0 ? `$${game.costPerHour.toFixed(2)}/hr` : 'Add price to calculate'}
                        </div>
                    </div>
                    <div class="game-editable-field">
                        <label for="price-${game.id}">Price ($)</label>
                        <input type="number" 
                               id="price-${game.id}" 
                               class="${priceInputClass}"
                               value="${game.totalCost > 0 ? game.totalCost : ''}" 
                               placeholder="0.00"
                               min="0" 
                               step="0.01"
                               onchange="updateGamePrice(${game.id}, this.value)">
                    </div>
                    <div class="game-editable-field">
                        <label for="hours-${game.id}">Hours</label>
                        <input type="number" 
                               id="hours-${game.id}" 
                               class="${hoursInputClass}"
                               value="${game.hoursPlayed > 0 ? game.hoursPlayed : ''}" 
                               placeholder="0"
                               min="0" 
                               step="0.1"
                               onchange="updateGameHours(${game.id}, this.value)">
                    </div>
                    <div class="game-actions">
                        <button class="remove-game-btn" onclick="removeGame(${game.id})">Remove</button>
                    </div>
                `;
                gamesListContent.appendChild(gameItem);
            });
            // Ensure scroll height shows ~10 rows
            applyScrollableHeights();
        }

        // Steam API functions
        async function connectSteam() {
            const steamId = steamIdInput.value.trim();
            if (!steamId) {
                showSteamStatus('error', 'Please enter a Steam ID or profile URL');
                return;
            }

            // Start rotating fun loading messages
            startLoadingMessages();
            steamConnectBtn.disabled = true;
            steamConnectBtn.textContent = 'Connecting...';

            try {
                // Parse Steam ID from various formats
                const parsedSteamId = parseSteamId(steamId);
                if (!parsedSteamId) {
                    throw new Error('Invalid Steam ID format. Please use a Steam ID or profile URL.');
                }

                // Get user profile data first
                const userData = await getSteamUserData(parsedSteamId);
                if (userData) {
                    steamUserData = userData;
                }
                
                // Get owned games
                const ownedGames = await getOwnedGames(parsedSteamId);
                
                if (ownedGames.length === 0) {
                    stopLoadingMessages();
                    showSteamStatus('error', 'No games found in your Steam library or profile is private.');
                    return;
                }

                // Import games (with fetched prices)
                const result = await importSteamGames(ownedGames);
                
                // Stop rotating messages and show success
                stopLoadingMessages();
                showSteamStatus('success', `Successfully imported ${result.importedCount} games from Steam!`);
                
                // Update games list UI
                updateGamesList();
                updateCalculateButtonState();

            } catch (error) {
                console.error('Steam API Error:', error);
                stopLoadingMessages();
                showSteamStatus('error', `Failed to connect to Steam: ${error.message}`);
            } finally {
                stopLoadingMessages();
                steamConnectBtn.disabled = false;
                steamConnectBtn.textContent = 'Connect Steam';
            }
        }

        function parseSteamId(input) {
            // Handle different Steam ID formats
            if (/^\d{17}$/.test(input)) {
                // Direct Steam ID (64-bit)
                return input;
            } else if (/steamcommunity\.com\/profiles\/(\d{17})/.test(input)) {
                // Steam profile URL with numeric ID (handles trailing slashes and query params)
                const match = input.match(/steamcommunity\.com\/profiles\/(\d{17})/);
                return match[1];
            } else if (/steamcommunity\.com\/id\/([^\/\?]+)/.test(input)) {
                // Steam profile URL with custom ID (handles trailing slashes and query params)
                const match = input.match(/steamcommunity\.com\/id\/([^\/\?]+)/);
                return match[1];
            } else if (/^[a-zA-Z0-9_-]+$/.test(input)) {
                // Custom Steam ID
                return input;
            }
            return null;
        }

        async function getOwnedGames(steamId) {
            // First, resolve custom Steam ID to numeric ID if needed
            let numericSteamId = steamId;
            if (!/^\d{17}$/.test(steamId)) {
                numericSteamId = await resolveSteamId(steamId);
                if (!numericSteamId) {
                    throw new Error('Could not resolve Steam ID');
                }
            }

            // Get owned games using CORS proxy
            const apiUrl = `${STEAM_API_BASE}/IPlayerService/GetOwnedGames/v0001/?key=${STEAM_API_KEY}&steamid=${numericSteamId}&format=json&include_appinfo=true`;
            const url = `${CORS_PROXY}${encodeURIComponent(apiUrl)}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Steam API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.response.games || [];
        }

        async function resolveSteamId(customId) {
            // Use CORS proxy for resolving custom Steam IDs
            const apiUrl = `${STEAM_API_BASE}/ISteamUser/ResolveVanityURL/v0001/?key=${STEAM_API_KEY}&vanityurl=${customId}`;
            const url = `${CORS_PROXY}${encodeURIComponent(apiUrl)}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Steam API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.response.steamid || null;
        }

        async function getSteamUserData(steamId) {
            // First, resolve custom Steam ID to numeric ID if needed
            let numericSteamId = steamId;
            if (!/^\d{17}$/.test(steamId)) {
                numericSteamId = await resolveSteamId(steamId);
                if (!numericSteamId) {
                    return null;
                }
            }

            // Get player summaries using CORS proxy
            const apiUrl = `${STEAM_API_BASE}/ISteamUser/GetPlayerSummaries/v0002/?key=${STEAM_API_KEY}&steamids=${numericSteamId}`;
            const url = `${CORS_PROXY}${encodeURIComponent(apiUrl)}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                return null;
            }
            
            const data = await response.json();
            const players = data.response.players || [];
            if (players.length > 0) {
                return {
                    personaname: players[0].personaname || '',
                    avatarmedium: players[0].avatarmedium || ''
                };
            }
            return null;
        }

        async function importSteamGames(ownedGames) {
            let importedCount = 0;
            let skippedCount = 0;
            
            // Limit to 100 games to prevent overwhelming the API and UI
            const gamesToImport = ownedGames.slice(0, 200);
            const totalGames = gamesToImport.length;
            
            // Step 1: Filter and prepare games to import
            // (Loading messages are rotating, no need for static messages)
            
            const validGames = [];
            for (const game of gamesToImport) {
                // Skip hidden games or games without names
                if (game.has_community_visible_stats === false || !game.name) {
                    skippedCount++;
                    continue;
                }
                
                // Convert playtime from minutes to hours (keep 0 hour games)
                const hoursPlayed = game.playtime_forever ? Math.round((game.playtime_forever / 60) * 10) / 10 : 0;
                
                // Check if game already exists
                const existingGame = games.find(g => g.name === game.name);
                if (existingGame) {
                    // Update hours played if Steam has more accurate data
                    if (hoursPlayed > existingGame.hoursPlayed) {
                        existingGame.hoursPlayed = hoursPlayed;
                        existingGame.costPerHour = existingGame.totalCost > 0 && hoursPlayed > 0 ? existingGame.totalCost / hoursPlayed : 0;
                    }
                    skippedCount++;
                    continue;
                }
                
                validGames.push({ ...game, hoursPlayed });
            }
            
            if (validGames.length === 0) {
                return { importedCount };
            }
            
            // Step 2: Batch fetch all prices at once (MUCH faster!)
            // (Loading messages are rotating automatically)
            const appIds = validGames.map(game => game.appid);
            const gamePrices = await fetchGamePricesBatch(appIds);
            
            // Step 3: Add all games with their fetched prices
            
            for (const game of validGames) {
                const gamePriceData = gamePrices[game.appid] || { initial: 0, final: 0 };
                const initialPrice = gamePriceData.initial || 0;
                const finalPrice = gamePriceData.final || 0;
                
                // Add new game with both initial and discounted prices
                const newGame = {
                    id: Date.now() + importedCount, // Simple ID generation
                    name: game.name,
                    cost: initialPrice,
                    finalCost: finalPrice, // Discounted/current price
                    dlcCost: 0,
                    hoursPlayed: game.hoursPlayed,
                    totalCost: initialPrice,
                    totalFinalCost: finalPrice,
                    costPerHour: initialPrice > 0 && game.hoursPlayed > 0 ? initialPrice / game.hoursPlayed : 0,
                    fromSteam: true, // Flag to indicate this came from Steam
                    appId: game.appid, // Store Steam app ID for reference
                    iconUrl: game.img_icon_url ? `https://media.steampowered.com/steamcommunity/public/images/apps/${game.appid}/${game.img_icon_url}.jpg` : null
                };
                
                games.push(newGame);
                importedCount++;
            }
            
            console.log(`Imported ${importedCount} games, skipped ${skippedCount} games (hidden or duplicates)`);
            
            return { importedCount };
        }

        // Single game price fetch - mainly for reference, batch method is preferred
        const fetchGamePrice = async (appId) => {
            const prices = await fetchGamePricesBatch([appId]);
            return prices[appId] || 0;
        };

        async function fetchGamePricesBatch(appIds) {
            // Batch fetch prices for multiple games at once
            // Steam API supports multiple appids in a single request
            try {
                const batchSize = 50; // Steam can handle ~100, but 50 is safer
                const batches = [];
                
                // Split appIds into batches
                for (let i = 0; i < appIds.length; i += batchSize) {
                    batches.push(appIds.slice(i, i + batchSize));
                }
                
                const allPrices = {};
                
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    
                    // Create comma-separated list of app IDs
                    const apiUrl = `https://store.steampowered.com/api/appdetails?appids=${batch.join(',')}&filters=price_overview&cc=US`;
                    const url = `${CORS_PROXY}${encodeURIComponent(apiUrl)}`;
                    
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            
                            // Parse all games in the batch
                            for (const appId of batch) {
                                if (data[appId] && data[appId].success && data[appId].data) {
                                    const priceData = data[appId].data.price_overview;
                                    if (priceData && priceData.initial) {
                                        allPrices[appId] = {
                                            initial: priceData.initial / 100,
                                            final: priceData.final / 100
                                        };
                                    } else {
                                        allPrices[appId] = { initial: 0, final: 0 }; // Free game
                                    }
                                } else {
                                    allPrices[appId] = { initial: 0, final: 0 }; // Price not available
                                }
                            }
                        } else {
                            // If batch fails, mark all as 0
                            batch.forEach(appId => allPrices[appId] = { initial: 0, final: 0 });
                        }
                    } catch (error) {
                        console.warn(`Batch ${batchIndex + 1} failed:`, error);
                        // Mark failed batch games as 0
                        batch.forEach(appId => allPrices[appId] = { initial: 0, final: 0 });
                    }
                    
                    // No delay needed - batching keeps us within rate limits
                }
                
                return allPrices;
            } catch (error) {
                console.error('Batch price fetch error:', error);
                return {};
            }
        }

        function showSteamStatus(type, message) {
            steamStatus.className = `steam-status ${type}`;
            steamStatus.textContent = message;
            steamStatus.style.display = 'block';
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    steamStatus.style.display = 'none';
                }, 5000);
            }
        }

        function startLoadingMessages() {
            // Clear any existing interval
            if (loadingMessageInterval) {
                clearInterval(loadingMessageInterval);
            }
            
            let messageIndex = 0;
            
            // Show first message immediately
            showSteamStatus('loading', LOADING_MESSAGES[messageIndex]);
            
            // Rotate through messages every 1 second
            loadingMessageInterval = setInterval(() => {
                messageIndex = (messageIndex + 1) % LOADING_MESSAGES.length;
                showSteamStatus('loading', LOADING_MESSAGES[messageIndex]);
            }, 1000);
        }

        function stopLoadingMessages() {
            if (loadingMessageInterval) {
                clearInterval(loadingMessageInterval);
                loadingMessageInterval = null;
            }
        }

        // Unified game update function
        function updateGameField(gameId, field, newValue) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;
            
            const value = parseFloat(newValue);
            if (isNaN(value) || value < 0) {
                // Reset to previous value if invalid
                const inputId = field === 'price' ? `price-${gameId}` : `hours-${gameId}`;
                const oldValue = field === 'price' ? game.totalCost : game.hoursPlayed;
                document.getElementById(inputId).value = oldValue > 0 ? oldValue : '';
                return;
            }
            
            // Update game fields
            if (field === 'price') {
                game.cost = value;
                game.totalCost = value;
                game.totalFinalCost = value; // For manually updated prices, assume no discount
            } else {
                game.hoursPlayed = value;
            }
            
            // Recalculate cost per hour
            game.costPerHour = game.totalCost > 0 && game.hoursPlayed > 0 ? game.totalCost / game.hoursPlayed : 0;
            updateGamesList();
        }

        const updateGamePrice = (gameId, newPrice) => updateGameField(gameId, 'price', newPrice);
        const updateGameHours = (gameId, newHours) => updateGameField(gameId, 'hours', newHours);


        // Unified error handling
        function toggleError(errorId, show, message = '') {
            const errorEl = document.getElementById(errorId);
            if (show) {
                errorEl.textContent = message;
                errorEl.style.display = 'block';
                errorEl.previousElementSibling.classList.add('error');
            } else {
                errorEl.style.display = 'none';
                errorEl.previousElementSibling.classList.remove('error');
            }
        }
        
        const showError = (id, msg) => toggleError(id, true, msg);
        const hideError = (id) => toggleError(id, false);

        function calculateROI() {
            if (games.length === 0) {
                alert('Please add at least one game before calculating.');
                return;
            }
            
            // Remove shiny animation from calculate button
            calculateBtn.classList.remove('shiny');
            
            // Animate card movement
            const inputCard = document.getElementById('inputCard');
            const advancedCard = document.querySelector('.shared-card:last-of-type'); // Advanced Assumptions card
            
            if (inputCard && advancedCard && advancedCard.parentNode) {
                // Add slide-up animation class
                inputCard.classList.add('card-slide-up');
                
                // Wait for animation to complete, then move the card
                setTimeout(() => {
                    advancedCard.parentNode.insertBefore(inputCard, advancedCard);
                    inputCard.classList.remove('card-slide-up');
                    inputCard.classList.add('card-slide-in');
                    
                    // Remove animation class after completion
                    setTimeout(() => {
                        inputCard.classList.remove('card-slide-in');
                    }, 600);
                }, 400);
            }
            
            // Collapse games list when calculating
            if (gamesList.style.display !== 'none') {
                gamesList.style.display = 'none';
                gamesListToggle.textContent = '‚ñ∂';
            }
            
            // Calculate aggregate metrics
            const totalCost = games.reduce((sum, game) => sum + game.totalCost, 0);
            const totalFinalCost = games.reduce((sum, game) => sum + (game.totalFinalCost || game.totalCost), 0);
            const totalHours = games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const aggregateCostPerHour = totalHours > 0 ? totalCost / totalHours : 0;
            const refundableCost = games.reduce((sum, game) => game.hoursPlayed < 2 ? sum + (game.totalFinalCost || game.totalCost) : sum, 0);
            
            // Update results display
            updateResults(aggregateCostPerHour, refundableCost, totalHours, totalCost, totalFinalCost);
            
            // Generate verdict
            generateVerdict(aggregateCostPerHour);
            
            // Update charts
            updateHoursDistributionChart(totalHours);
            updateScatterChart();
            updateComparisonChart();
            
            // Show results
            verdictCard.style.display = 'block';
            resultsCard.style.display = 'block';
            individualGamesSection.style.display = 'block';
            updateIndividualGamesMetrics();
            updateGameDistribution(totalHours);
        }

        function updateGameDistribution(totalHours) {
            // Sort games by hours played (descending)
            const sortedGames = [...games].sort((a, b) => b.hoursPlayed - a.hoursPlayed);
            
            // Filter out games with 0 hours
            const playedGames = sortedGames.filter(game => game.hoursPlayed > 0);
            
            if (playedGames.length === 0) {
                document.getElementById('gameDistribution').style.display = 'none';
                return;
            }
            
            // Calculate cumulative hours until we reach 50% of total
            let cumulativeHours = 0;
            const threshold = totalHours * 0.5;
            const topGames = [];
            
            for (const game of playedGames) {
                topGames.push(game);
                cumulativeHours += game.hoursPlayed;
                if (cumulativeHours >= threshold) {
                    break;
                }
            }
            
            // Only show if there are 5 or fewer top games (meaningful concentration)
            if (topGames.length > 0 && topGames.length <= 5) {
                const percentage = Math.round((cumulativeHours / totalHours) * 100);
                const gameText = topGames.length === 1 ? 'game' : 'games';
                
                document.getElementById('gameDistributionText').textContent = 
                    `Over ${percentage}% of your total game hours was spent playing ${topGames.length === 1 ? 'this' : 'these'} ${topGames.length} ${gameText}:`;
                
                // Build the top games display
                const topGamesDisplay = document.getElementById('topGamesDisplay');
                topGamesDisplay.innerHTML = '';
                
                topGames.forEach(game => {
                    const gameDiv = document.createElement('div');
                    gameDiv.style.textAlign = 'center';
                    
                    if (game.iconUrl) {
                        const img = document.createElement('img');
                        img.src = game.iconUrl;
                        img.alt = game.name;
                        img.style.width = '64px';
                        img.style.height = '64px';
                        img.style.borderRadius = '8px';
                        img.style.marginBottom = '8px';
                        img.style.display = 'block';
                        img.style.margin = '0 auto 8px auto';
                        gameDiv.appendChild(img);
                    }
                    
                    const nameSpan = document.createElement('div');
                    nameSpan.textContent = game.name;
                    nameSpan.style.fontSize = '0.9em';
                    nameSpan.style.color = '#2c5aa0';
                    nameSpan.style.maxWidth = '120px';
                    nameSpan.style.wordWrap = 'break-word';
                    gameDiv.appendChild(nameSpan);
                    
                    const hoursSpan = document.createElement('div');
                    hoursSpan.textContent = `${game.hoursPlayed.toFixed(1)} hrs`;
                    hoursSpan.style.fontSize = '0.8em';
                    hoursSpan.style.color = '#666';
                    hoursSpan.style.marginTop = '4px';
                    gameDiv.appendChild(hoursSpan);
                    
                    topGamesDisplay.appendChild(gameDiv);
                });
                
                document.getElementById('gameDistribution').style.display = 'block';
            } else {
                document.getElementById('gameDistribution').style.display = 'none';
            }
        }

        function updateResults(costPerHour, refundableCost, totalGamingHours, totalCost, totalFinalCost) {
            // Update total games in library
            const totalGamesInLibraryEl = document.getElementById('totalGamesInLibrary');
            totalGamesInLibraryEl.textContent = games.length.toLocaleString('en-US');
            totalGamesInLibraryEl.className = 'value';
            
            // Update total gaming hours
            const totalGamingHoursEl = document.getElementById('totalGamingHours');
            totalGamingHoursEl.textContent = totalGamingHours.toLocaleString('en-US', { maximumFractionDigits: 1 });
            totalGamingHoursEl.className = 'value';
            
            // Update cost per hour with color coding
            aggregateCostPerHourEl.textContent = `$${costPerHour.toFixed(2)}/hr`;
            aggregateCostPerHourEl.className = 'value ' + getCostPerHourColorClass(costPerHour);
            
            // Update total cost of gaming (show range if there are discounts)
            const totalCostOfGamingEl = document.getElementById('totalCostOfGaming');
            if (totalFinalCost < totalCost) {
                totalCostOfGamingEl.textContent = `$${totalFinalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} - $${totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            } else {
                totalCostOfGamingEl.textContent = `$${totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            }
            totalCostOfGamingEl.className = 'value';
            
            // Update the label
            const totalCostLabelEl = totalCostOfGamingEl.nextElementSibling;
            if (totalCostLabelEl && totalFinalCost < totalCost) {
                totalCostLabelEl.textContent = 'Total Cost of Gaming (depending on discounts)';
            } else if (totalCostLabelEl) {
                totalCostLabelEl.textContent = 'Total Cost of Gaming';
            }
            
            // Update refundable games count with color coding
            const refundableCount = games.filter(game => game.hoursPlayed < 2).length;
            const refundableGamesPercent = games.length > 0 ? (refundableCount / games.length) * 100 : 0;
            
            // Update the value (count of refundable games)
            const refundableValueEl = refundableCostEl;
            refundableValueEl.textContent = refundableCount.toLocaleString('en-US');
            
            // Color code based on percentage of games that are refundable
            if (refundableGamesPercent < 10) {
                refundableValueEl.className = 'value elite'; // Elite
            } else if (refundableGamesPercent < 25) {
                refundableValueEl.className = 'value solid'; // Solid
            } else if (refundableGamesPercent < 35) {
                refundableValueEl.className = 'value reasonable'; // Reasonable
            } else if (refundableGamesPercent < 50) {
                refundableValueEl.className = 'value premium'; // Premium
            } else {
                refundableValueEl.className = 'value yikes'; // Yikes
            }
        }

        // Unified color class function based on thresholds
        function getColorClass(value, thresholds = [1, 3, 8, 15, 30]) {
            const classes = ['legendary', 'elite', 'solid', 'reasonable', 'premium', 'yikes'];
            const index = thresholds.findIndex(threshold => value <= threshold);
            return index === -1 ? classes[classes.length - 1] : classes[index];
        }

        const getCostPerHourColorClass = (cph) => getColorClass(cph, [0.40, 1.50, 3.50, 6.00, 10.00]);
        const getHoursOfWorkColorClass = (hours) => getColorClass(hours, [1, 3, 8, 15, 30]);
        
        // Global sort state for table - default to sorting by initial cost descending
        let currentSortColumn = 'totalCost';
        let currentSortDirection = 'desc';

        function updateIndividualGamesMetrics() {
            gamesMetrics.innerHTML = '';
            
            const table = document.createElement('table');
            table.className = 'games-table';
            
            // Create table header with sortable columns
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = `
                <th class="sortable" data-column="name">Game</th>
                <th class="sortable cost-per-hour" data-column="totalCost">Initial Cost</th>
                <th class="sortable hours-work" data-column="hoursPlayed">Total Hours</th>
                <th class="sortable cost-per-hour" data-column="costPerHour">Cost per Hour</th>
            `;
            table.appendChild(headerRow);
            
            // Add click handlers to sortable headers
            headerRow.querySelectorAll('th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.column;
                    if (currentSortColumn === column) {
                        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSortColumn = column;
                        currentSortDirection = 'asc';
                    }
                    updateIndividualGamesMetrics();
                });
                
                // Add sort indicators
                if (th.dataset.column === currentSortColumn) {
                    th.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
            
            // Sort games based on current column and direction
            let sortedGames = [...games];
            if (currentSortColumn) {
                sortedGames.sort((a, b) => {
                    let aVal, bVal;
                    
                    if (currentSortColumn === 'name') {
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                        return currentSortDirection === 'asc' 
                            ? aVal.localeCompare(bVal) 
                            : bVal.localeCompare(aVal);
                    } else if (currentSortColumn === 'hoursOfWork') {
                        aVal = hourlyIncome && hourlyIncome > 0 ? a.totalCost / hourlyIncome : 0;
                        bVal = hourlyIncome && hourlyIncome > 0 ? b.totalCost / hourlyIncome : 0;
                    } else {
                        aVal = a[currentSortColumn] || 0;
                        bVal = b[currentSortColumn] || 0;
                    }
                    
                    return currentSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                });
            }
            
            // Create table rows for each game
            sortedGames.forEach(game => {
                // Special case: if game has $0 CPH because it was purchased but never played, color it red
                let costPerHourClass;
                if (game.costPerHour === 0 && game.totalCost > 0 && game.hoursPlayed === 0) {
                    costPerHourClass = 'yikes';  // Red for never-played purchased games
                } else {
                    costPerHourClass = getCostPerHourColorClass(game.costPerHour);
                }
                
                // Add game icon if available
                const gameIcon = game.iconUrl ? `<img src="${game.iconUrl}" alt="${game.name}" class="game-icon" onerror="this.style.display='none'">` : '';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="game-name">
                        ${gameIcon}
                        <span>${game.name}</span>
                    </td>
                    <td class="cost-per-hour">
                        <span class="metric-value">$${game.totalCost.toFixed(2)}</span>
                    </td>
                    <td class="hours-work">
                        <span class="metric-value">${game.hoursPlayed.toFixed(1)}</span>
                    </td>
                    <td class="cost-per-hour">
                        <span class="metric-value metric-${costPerHourClass}">$${game.costPerHour.toFixed(2)}/hr</span>
                    </td>
                `;
                table.appendChild(row);
            });
            
            gamesMetrics.appendChild(table);
            // Ensure scroll height shows header + ~10 data rows
            applyScrollableHeights();
        }

        function generateVerdict(costPerHour) {
            // Calculate additional metrics for grading
            const totalCost = games.reduce((sum, game) => sum + game.totalCost, 0);
            const totalHours = games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const neverPlayedCost = games.reduce((sum, game) => game.hoursPlayed === 0 ? sum + game.totalCost : sum, 0);
            const neverPlayedPercent = totalCost > 0 ? (neverPlayedCost / totalCost) * 100 : 0;
            
            // Calculate refundability (games with < 2 hours)
            const refundableCount = games.filter(game => game.hoursPlayed < 2).length;
            const refundablePercent = games.length > 0 ? (refundableCount / games.length) * 100 : 0;
            
            // ==============================================
            // LETTER GRADE CALCULATION
            // Weighted: CPH (60%), Refundability (30%), Backlog (10%)
            // ==============================================
            
            let backlogScore = 0;
            let cphScore = 0;
            let refundabilityScore = 0;
            
            // Factor 1: Gaming spend breakdown (never played %) - 10 points
            // <25% = excellent, >50% = failing
            if (neverPlayedPercent < 10) {
                backlogScore = 10;
            } else if (neverPlayedPercent < 25) {
                backlogScore = 8;
            } else if (neverPlayedPercent < 35) {
                backlogScore = 5;
            } else if (neverPlayedPercent < 50) {
                backlogScore = 3;
            } else {
                backlogScore = 0;
            }
            
            // Factor 2: Cost per hour - 60 points (MOST IMPORTANT)
            // Align with existing buckets
            if (costPerHour <= 0.40) {
                cphScore = 60; // Legendary
            } else if (costPerHour <= 1.50) {
                cphScore = 52; // Elite
            } else if (costPerHour <= 3.50) {
                cphScore = 40; // Solid
            } else if (costPerHour <= 6.00) {
                cphScore = 25; // Reasonable
            } else if (costPerHour <= 10.00) {
                cphScore = 10; // Premium
            } else {
                cphScore = 0; // Yikes
            }
            
            // Factor 3: Refundability - 30 points
            // Lower refundable % = better score
            if (refundablePercent < 10) {
                refundabilityScore = 30; // Elite
            } else if (refundablePercent < 25) {
                refundabilityScore = 25; // Solid
            } else if (refundablePercent < 35) {
                refundabilityScore = 18; // Reasonable
            } else if (refundablePercent < 50) {
                refundabilityScore = 10; // Premium
            } else {
                refundabilityScore = 0; // Yikes
            }
            
            const score = backlogScore + cphScore + refundabilityScore;
            
            // Convert score to letter grade with +/- granularity and color coding
            let letterGrade = '';
            let gradeColor = '';
            if (score >= 97) {
                letterGrade = 'A+';
                gradeColor = '#4CAF50'; // Green
            } else if (score >= 93) {
                letterGrade = 'A';
                gradeColor = '#4CAF50'; // Green
            } else if (score >= 90) {
                letterGrade = 'A-';
                gradeColor = '#4CAF50'; // Green
            } else if (score >= 87) {
                letterGrade = 'B+';
                gradeColor = '#2196F3'; // Blue
            } else if (score >= 83) {
                letterGrade = 'B';
                gradeColor = '#2196F3'; // Blue
            } else if (score >= 80) {
                letterGrade = 'B-';
                gradeColor = '#2196F3'; // Blue
            } else if (score >= 77) {
                letterGrade = 'C+';
                gradeColor = '#FFC107'; // Yellow/Amber
            } else if (score >= 73) {
                letterGrade = 'C';
                gradeColor = '#FFC107'; // Yellow/Amber
            } else if (score >= 70) {
                letterGrade = 'C-';
                gradeColor = '#FFC107'; // Yellow/Amber
            } else if (score >= 67) {
                letterGrade = 'D+';
                gradeColor = '#FF9800'; // Orange
            } else if (score >= 63) {
                letterGrade = 'D';
                gradeColor = '#FF9800'; // Orange
            } else if (score >= 60) {
                letterGrade = 'D-';
                gradeColor = '#FF9800'; // Orange
            } else {
                letterGrade = 'F';
                gradeColor = '#F44336'; // Red
            }
            
            // Build verdict HTML with avatar and username above
            const userName = steamUserData.personaname;
            const avatarUrl = steamUserData.avatarmedium;
            
            let verdictHTML = '';
            
            // Add Steam ID line above if available
            if (userName && avatarUrl) {
                verdictHTML += '<div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 15px;">';
                verdictHTML += `<img src="${avatarUrl}" alt="Steam Avatar" style="border-radius: 50%; width: 32px; height: 32px;">`;
                verdictHTML += `<span style="font-size: 1.2em; color: #666;">${userName} | Gaming Report Card</span>`;
                verdictHTML += '</div>';
            }
            
            // Main grade line
            verdictHTML += `<span style="font-size: 4em; font-weight: bold;">Your Grade: <span style="color: ${gradeColor};">${letterGrade}</span></span>`;
            
            verdictTextEl.innerHTML = verdictHTML;
            
            // Generate feedback message based on grade and component scores
            let feedbackMessage = '';
            
            // Normalize scores to percentages for comparison
            const backlogPercent_normalized = (backlogScore / 10) * 100;
            const cphPercent_normalized = (cphScore / 60) * 100;
            const refundabilityPercent_normalized = (refundabilityScore / 30) * 100;
            
            const components = [
                { name: 'backlog', percent: backlogPercent_normalized, score: backlogScore },
                { name: 'cph', percent: cphPercent_normalized, score: cphScore },
                { name: 'refundability', percent: refundabilityPercent_normalized, score: refundabilityScore }
            ];
            
            // Grade 85+ - identify and describe best component
            if (score >= 85) {
                // Find best component
                const bestComponent = components.reduce((best, current) => 
                    current.percent > best.percent ? current : best
                );
                
                if (bestComponent.name === 'backlog') {
                    feedbackMessage = `You play ${(100 - neverPlayedPercent).toFixed(0)}% of the games you buy.`;
                } else if (bestComponent.name === 'cph') {
                    feedbackMessage = `Your average cost is $${costPerHour.toFixed(2)} per hour of entertainment.`;
                } else {
                    feedbackMessage = `${(100 - refundablePercent).toFixed(0)}% of your games were kept past the refund window.`;
                }
            }
            // Grade 84 and below - identify and describe worst component
            else {
                // Find worst component
                const worstComponent = components.reduce((worst, current) => 
                    current.percent < worst.percent ? current : worst
                );
                
                if (worstComponent.name === 'backlog') {
                    feedbackMessage = `${neverPlayedPercent.toFixed(0)}% of your spending went to games you haven't played.`;
                } else if (worstComponent.name === 'cph') {
                    feedbackMessage = `Your cost per hour of $${costPerHour.toFixed(2)} is higher than average.`;
                } else {
                    feedbackMessage = `${refundablePercent.toFixed(0)}% of your games could have been refunded.`;
                }
            }
            
            if (feedbackMessage) {
                verdictSubtextEl.innerHTML = `<span style="font-size: 1.2em; color: #666; margin-top: 15px; display: block;">${feedbackMessage}</span>`;
            } else {
                verdictSubtextEl.textContent = '';
            }
        }

        function updateHoursDistributionChart(totalHours) {
            const ctx = getChartContext('spendPieChart', spendPieChart);
            
            // Sort games by hours played (descending)
            const sortedGames = [...games].sort((a, b) => b.hoursPlayed - a.hoursPlayed);
            
            // Get top 5 games
            const top3Games = sortedGames.slice(0, 5).filter(game => game.hoursPlayed > 0);
            
            // Calculate hours for "the rest"
            const top3Hours = top3Games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const restHours = totalHours - top3Hours;
            
            // Build labels and data arrays
            const labels = top3Games.map(game => game.name);
            const data = top3Games.map(game => game.hoursPlayed);
            
            // Add "The rest of your library" if there are more games
            if (restHours > 0) {
                labels.push('The rest of your library');
                data.push(restHours);
            }
            
            // Generate colors for top games (enough for 5 games + "the rest")
            const colors = [
                'rgba(74, 144, 226, 0.7)',   // Blue
                'rgba(126, 211, 33, 0.7)',   // Green
                'rgba(255, 152, 0, 0.7)',    // Orange
                'rgba(156, 39, 176, 0.7)',   // Purple
                'rgba(244, 67, 54, 0.7)',    // Red
                'rgba(158, 158, 158, 0.5)'   // Gray for "the rest"
            ];
            
            const borderColors = [
                'rgba(74, 144, 226, 1)',
                'rgba(126, 211, 33, 1)',
                'rgba(255, 152, 0, 1)',
                'rgba(156, 39, 176, 1)',
                'rgba(244, 67, 54, 1)',
                'rgba(158, 158, 158, 1)'
            ];
            
            spendPieChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors.slice(0, labels.length),
                        borderColor: borderColors.slice(0, labels.length),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                font: {
                                    family: 'Yu Gothic UI, sans-serif',
                                    size: 14
                                },
                                color: '#2c5aa0',
                                padding: 15,
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            titleColor: '#2c5aa0',
                            bodyColor: '#2c5aa0',
                            borderColor: '#2c5aa0',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const percentage = ((value / totalHours) * 100).toFixed(1);
                                    return `${label}: ${value.toFixed(1)} hrs (${percentage}%)`;
                                }
                            }
                        },
                        datalabels: {
                            display: false
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function updateScatterChart() {
            const ctx = getChartContext('scatterChart', scatterChart);
            
            // Compute effectiveHours and CPH for each game
            const computedData = games.map(game => {
                const isNeverPlayed = game.hoursPlayed === 0;
                // Check outlier status BEFORE applying effectiveHours logic
                const isOutlier = !isNeverPlayed && game.hoursPlayed > H_CAP;
                
                // Calculate effectiveHours for plotting purposes only
                let effectiveHours;
                if (isNeverPlayed) {
                    effectiveHours = 0.1;  // Never-played games - for plotting only
                } else if (isOutlier) {
                    effectiveHours = game.hoursPlayed;  // Use true hours for outliers
                } else {
                    effectiveHours = Math.max(game.hoursPlayed, 0.5);  // Normal games - minimum 0.5 for plotting
                }
                
                // Use stored CPH from game object for consistency with table
                // For plotting, handle special cases to ensure all games are plottable on log scale
                let plotCph;
                if (isNeverPlayed) {
                    // Never-played games: plot at high CPH if they cost money, or at 0.05 if free
                    plotCph = game.totalCost > 0 ? game.totalCost / 0.1 : 0.0013;
                } else if (game.totalCost === 0) {
                    // Free games that have been played: plot at 0.05 CPH (low but hoverable)
                    // This ensures they appear in "Evergreen value" quadrant but remain accessible
                    plotCph = 0.0013;
                } else if (game.hoursPlayed > 0) {
                    // Normal paid games: use actual CPH
                    plotCph = game.totalCost / game.hoursPlayed;
                } else {
                    // Fallback: should not happen but handle it
                    plotCph = 0.0013;
                }
                
                const plotHours = isOutlier ? H_CAP : effectiveHours;
                
                // Store both plot CPH (for positioning) and actual CPH (for tooltip)
                const actualCph = game.costPerHour;  // From game object
                const isFreeGame = game.totalCost === 0;
                
                return {
                    name: game.name,
                    effectiveHours: effectiveHours,
                    plotHours: plotHours,
                    cph: plotCph,  // Used for plotting position on y-axis
                    actualCph: actualCph,  // True CPH for tooltip display
                    costUsd: game.totalCost,
                    hoursPlayed: game.hoursPlayed,
                    isNeverPlayed: isNeverPlayed,
                    isOutlier: isOutlier,
                    isFreeGame: isFreeGame,
                    iconUrl: game.iconUrl
                };
            });
            
            // Split data into main points and outliers
            const mainPoints = computedData.filter(d => !d.isOutlier);
            const outlierPoints = computedData.filter(d => d.isOutlier);
            
            // Debug logging
            console.log(`Total games: ${computedData.length}, Main: ${mainPoints.length}, Outliers: ${outlierPoints.length}`);
            console.log('All computed data:', computedData.map(d => `${d.name}: ${d.hoursPlayed}h, isOutlier: ${d.isOutlier}`));
            if (outlierPoints.length > 0) {
                console.log('Outlier games (>200h):', outlierPoints.map(d => `${d.name}: ${d.hoursPlayed}h ‚Üí plotted at ${d.plotHours}h, CPH: $${d.cph.toFixed(2)}`));
            }
            
            // Compute medians on main points only (for quadrant division)
            const mainHoursSorted = mainPoints.map(d => d.plotHours).sort((a, b) => a - b);
            const mainCphSorted = mainPoints.map(d => d.cph).sort((a, b) => a - b);
            
            const medianHours = mainHoursSorted.length > 0
                ? (mainHoursSorted.length % 2 === 0
                    ? (mainHoursSorted[mainHoursSorted.length / 2 - 1] + mainHoursSorted[mainHoursSorted.length / 2]) / 2
                    : mainHoursSorted[Math.floor(mainHoursSorted.length / 2)])
                : H_CAP / 2;
            
            const medianCph = mainCphSorted.length > 0
                ? (mainCphSorted.length % 2 === 0
                    ? (mainCphSorted[mainCphSorted.length / 2 - 1] + mainCphSorted[mainCphSorted.length / 2]) / 2
                    : mainCphSorted[Math.floor(mainCphSorted.length / 2)])
                : 1;
            
            // Assign quadrant and color based on plot position
            const getQuadrant = (plotHours, cph) => {
                const isLeft = plotHours <= medianHours;
                const isTop = cph >= medianCph;
                if (isLeft && isTop) return { label: 'Backlog shame', color: 'rgba(244, 67, 54, 0.7)' }; // Red
                if (!isLeft && isTop) return { label: 'Luxury hobby', color: 'rgba(255, 152, 0, 0.7)' }; // Orange
                if (isLeft && !isTop) return { label: 'Casual win', color: 'rgba(33, 150, 243, 0.7)' }; // Blue
                return { label: 'Evergreen value', color: 'rgba(76, 175, 80, 0.7)' }; // Green
            };
            
            // Helper function to apply jitter to prevent overlapping points
            // Uses seeded random based on game name for consistent placement
            const applyJitter = (value, gameName, scale = 1) => {
                // Simple hash function for seeded randomness
                let hash = 0;
                for (let i = 0; i < gameName.length; i++) {
                    hash = ((hash << 5) - hash) + gameName.charCodeAt(i);
                    hash = hash & hash;
                }
                // Convert hash to number between -1 and 1
                const normalized = (hash % 1000) / 500 - 1;
                // Apply jitter: ¬±15% for log scale
                const jitterFactor = 0.15 * scale;
                return value * (1 + normalized * jitterFactor);
            };
            
            // Detect overlapping points and apply jitter where needed
            const detectOverlap = (points, axisRanges) => {
                const overlaps = new Set();
                const { xMin, xMax, yMin, yMax } = axisRanges;
                
                // Check point-to-point overlaps
                for (let i = 0; i < points.length; i++) {
                    for (let j = i + 1; j < points.length; j++) {
                        const point1 = points[i];
                        const point2 = points[j];
                        
                        // Check if within ¬±10% on both axes
                        const xRatio = point1.plotHours / point2.plotHours;
                        const yRatio = point1.cph / point2.cph;
                        
                        const xWithin10Percent = xRatio >= 0.9 && xRatio <= 1.1;
                        const yWithin10Percent = yRatio >= 0.9 && yRatio <= 1.1;
                        
                        if (xWithin10Percent && yWithin10Percent) {
                            overlaps.add(i);
                            overlaps.add(j);
                        }
                    }
                }
                
                // Check for overlaps with quadrant labels and axis labels
                // Define regions where text labels appear (approximate % of chart, expanded for better coverage)
                const labelRegions = [
                    // Quadrant labels (corners) - expanded regions for better text protection
                    { xMin: 0, xMax: 0.20, yMin: 0.80, yMax: 1.0, name: 'top-left' },      // Backlog shame
                    { xMin: 0.80, xMax: 1.0, yMin: 0.80, yMax: 1.0, name: 'top-right' },   // Luxury hobby
                    { xMin: 0, xMax: 0.20, yMin: 0, yMax: 0.20, name: 'bottom-left' },     // Casual win
                    { xMin: 0.80, xMax: 1.0, yMin: 0, yMax: 0.20, name: 'bottom-right' },  // Evergreen value
                    // Axis labels
                    { xMin: 0.78, xMax: 1.0, yMin: 0.42, yMax: 0.58, name: 'horizontal-axis' }, // Hours Played (right)
                    { xMin: 0.42, xMax: 0.58, yMin: 0.80, yMax: 1.0, name: 'vertical-axis' }    // Effective Cost (top)
                ];
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    
                    // Normalize point coordinates to 0-1 range for comparison with label regions
                    const normalizedX = (Math.log10(point.plotHours) - Math.log10(xMin)) / 
                                       (Math.log10(xMax) - Math.log10(xMin));
                    const normalizedY = (Math.log10(point.cph) - Math.log10(yMin)) / 
                                       (Math.log10(yMax) - Math.log10(yMin));
                    
                    // Check if point falls within any label region
                    for (const region of labelRegions) {
                        if (normalizedX >= region.xMin && normalizedX <= region.xMax &&
                            normalizedY >= region.yMin && normalizedY <= region.yMax) {
                            overlaps.add(i);
                            break;
                        }
                    }
                }
                
                return overlaps;
            };
            
            // Calculate axis ranges FIRST (needed for overlap detection)
            const tempMainDataset = mainPoints.map(d => ({ x: d.plotHours, y: d.cph }));
            const tempOutlierDataset = outlierPoints.map(d => ({ x: d.plotHours, y: d.cph }));
            const tempAllPoints = [...tempMainDataset, ...tempOutlierDataset];
            const tempXValues = tempAllPoints.map(d => d.x).filter(x => x > 0);
            const tempYValues = tempAllPoints.map(d => d.y).filter(y => y > 0);
            const tempNonZeroYValues = tempYValues.filter(y => y > 0.001);
            
            const xMin = 0.05;
            const xMax = H_CAP * 1.2;
            const yMin = tempNonZeroYValues.length > 0 
                ? Math.min(0.001, Math.min(...tempNonZeroYValues) * 0.1)
                : 0.001;
            const yMax = Math.max(...tempYValues) * 2;
            
            const overlappingIndices = detectOverlap(mainPoints, { xMin, xMax, yMin, yMax });
            
            // Create main dataset with jitter applied to overlapping points
            const mainDataset = mainPoints.map((d, index) => {
                const quad = getQuadrant(d.plotHours, d.cph);
                const radius = 16;
                
                // Apply jitter to overlapping points (especially 0-hour games)
                const needsJitter = overlappingIndices.has(index) || d.isNeverPlayed;
                const plottedX = needsJitter ? applyJitter(d.plotHours, d.name, 1.0) : d.plotHours;
                const plottedY = needsJitter ? applyJitter(d.cph, d.name + '_y', 0.8) : d.cph;
                
                return {
                    x: plottedX,
                    y: plottedY,
                    label: d.name,
                    costUsd: d.costUsd,
                    hoursPlayed: d.hoursPlayed,  // Keep true hours for tooltip
                    effectiveHours: d.effectiveHours,
                    cph: d.actualCph,  // Use actual CPH for tooltip (not plot CPH)
                    isNeverPlayed: d.isNeverPlayed,
                    isFreeGame: d.isFreeGame,
                    isOutlier: false,
                    quadrant: quad.label,
                    borderColor: d.isNeverPlayed ? 'rgba(150, 0, 0, 1)' : quad.color,
                    borderWidth: d.isNeverPlayed ? 3 : 2,
                    iconUrl: d.iconUrl
                };
            });
            
            // Create outlier dataset
            const outlierDataset = outlierPoints.map(d => {
                const quad = getQuadrant(d.plotHours, d.cph);
                const radius = 16;
                
                return {
                    x: d.plotHours,
                    y: d.cph,
                    label: d.name,
                    costUsd: d.costUsd,
                    hoursPlayed: d.hoursPlayed,
                    effectiveHours: d.effectiveHours,
                    cph: d.actualCph,  // Use actual CPH for tooltip
                    isFreeGame: d.isFreeGame,
                    isNeverPlayed: false,
                    isOutlier: true,
                    quadrant: quad.label,
                    borderColor: quad.color,
                    borderWidth: 3,
                    iconUrl: d.iconUrl
                };
            });
            
            // Create icon images for both datasets
            const mainIcons = mainDataset.map(d => {
                if (d.iconUrl) {
                    const img = new Image(32, 32);
                    img.src = d.iconUrl;
                    img.onload = () => {
                        if (scatterChart) scatterChart.update('none');
                    };
                    return img;
                }
                return d.isNeverPlayed ? 'triangle' : 'circle';
            });
            
            const outlierIcons = outlierDataset.map((d, idx) => {
                if (d.iconUrl) {
                    const img = new Image(32, 32);
                    img.src = d.iconUrl;
                    console.log(`Loading outlier icon ${idx}: ${d.label} from ${d.iconUrl}`);
                    img.onload = () => {
                        console.log(`Outlier icon ${idx} loaded: ${d.label}`);
                        if (scatterChart) scatterChart.update('none');
                    };
                    return img;
                }
                return 'circle';
            });
            
            console.log('Outlier dataset:', outlierDataset.map(d => `${d.label}: x=${d.x}, y=${d.y.toFixed(2)}`));
            
            // Chart.js scatter with log scales and two datasets
            scatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        // Main points dataset
                        {
                            label: 'Games',
                            data: mainDataset,
                            pointStyle: 'circle',
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            borderWidth: 0,
                            pointRadius: 16,
                            pointHoverRadius: 20
                        },
                        // Outliers dataset (200h+ capped)
                        {
                            label: '200h+ capped',
                            data: outlierDataset,
                            pointStyle: 'circle',
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            borderWidth: 0,
                            pointRadius: 16,
                            pointHoverRadius: 20,
                            borderDash: [5, 5]  // Dashed for distinction
                        }
                    ]
                },
                plugins: [{
                    id: 'circularIcons',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        
                        // Draw main dataset (dataset 0)
                        const mainMeta = chart.getDatasetMeta(0);
                        mainMeta.data.forEach((point, index) => {
                            const d = mainDataset[index];
                            const img = mainIcons[index];
                            const x = point.x;
                            const y = point.y;
                            const radius = point.options.radius || 16;
                            
                            if (img instanceof Image && img.complete) {
                                // Draw circular clipped image (no border)
                                ctx.save();
                                ctx.beginPath();
                                ctx.arc(x, y, radius, 0, Math.PI * 2);
                                ctx.closePath();
                                ctx.clip();
                                ctx.drawImage(img, x - radius, y - radius, radius * 2, radius * 2);
                                ctx.restore();
                            } else {
                                // Draw shape for never-played or no-icon games
                                ctx.beginPath();
                                if (d.isNeverPlayed) {
                                    // Triangle for never-played
                                    ctx.moveTo(x, y - radius);
                                    ctx.lineTo(x + radius, y + radius);
                                    ctx.lineTo(x - radius, y + radius);
                                    ctx.closePath();
                                } else {
                                    // Circle
                                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                                }
                                ctx.fillStyle = d.borderColor; // Use the color but no border
                                ctx.fill();
                            }
                        });
                        
                        // Draw outlier dataset (dataset 1) with dashed borders
                        if (chart.data.datasets.length > 1) {
                            const outlierMeta = chart.getDatasetMeta(1);
                            console.log('Outlier meta points:', outlierMeta.data.length, 'Expected:', outlierDataset.length);
                            outlierMeta.data.forEach((point, index) => {
                                const d = outlierDataset[index];
                                const img = outlierIcons[index];
                                const x = point.x;
                                const y = point.y;
                                const radius = point.options.radius || 16;
                                console.log(`Drawing outlier ${index}: ${d.label} at (${x}, ${y}), img loaded:`, img instanceof Image && img.complete);
                                
                                if (img instanceof Image && img.complete) {
                                    // Draw circular clipped image (no border)
                                    ctx.save();
                                    ctx.beginPath();
                                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                                    ctx.closePath();
                                    ctx.clip();
                                    ctx.drawImage(img, x - radius, y - radius, radius * 2, radius * 2);
                                    ctx.restore();
                                } else {
                                    // Draw circle without border
                                    ctx.beginPath();
                                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                                    ctx.fillStyle = d.borderColor; // Use the color but no border
                                    ctx.fill();
                                }
                            });
                        }
                    }
                }],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { 
                        mode: 'nearest', 
                        intersect: false,
                        includeInvisible: false,
                        axis: 'xy'
                    },
                    plugins: {
                        title: {
                            display: false  // Title moved to HTML element above chart
                        },
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            displayColors: false,
                            mode: 'nearest',
                            callbacks: {
                                title: (ctx) => {
                                    // If multiple items, only show game names
                                    if (ctx.length > 1) {
                                        return ctx.map(item => item.raw.label).join(', ');
                                    }
                                    return ctx[0]?.raw?.label || 'Unknown';
                                },
                                label: (ctx) => {
                                    // If multiple items are hovered, don't show details
                                    const tooltipItems = ctx.chart.tooltip.dataPoints || [];
                                    if (tooltipItems.length > 1) {
                                        return null;  // Don't show label lines when multiple games are hovered
                                    }
                                    
                                    const d = ctx.raw;
                                    const lines = [
                                        `Hours played: ${d.hoursPlayed.toFixed(1)}`,  // True hours
                                        `Total cost: $${d.costUsd.toFixed(2)}`,
                                        `Cost per hour: $${d.cph.toFixed(2)}`
                                    ];
                                    if (d.isFreeGame) {
                                        lines.push('Status: Free game');
                                    }
                                    if (d.isNeverPlayed) {
                                        lines.push('Status: Never played');
                                    }
                                    if (d.isOutlier) {
                                        lines.push(`Note: Plotted at ${H_CAP}h cap (actual: ${d.hoursPlayed.toFixed(1)}h)`);
                                    }
                                    return lines;
                                },
                                beforeBody: (ctx) => {
                                    // If multiple items, add separator line
                                    if (ctx.length > 1) {
                                        return '';
                                    }
                                    return null;
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                medianVLine: {
                                    type: 'line',
                                    xMin: medianHours,
                                    xMax: medianHours,
                                    borderColor: 'rgba(100, 100, 100, 0.3)',
                                    borderWidth: 2,
                                    borderDash: [3, 3]
                                },
                                medianHLine: {
                                    type: 'line',
                                    yMin: medianCph,
                                    yMax: medianCph,
                                    borderColor: 'rgba(100, 100, 100, 0.3)',
                                    borderWidth: 2,
                                    borderDash: [3, 3]
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            min: xMin,
                            max: xMax,
                            title: {
                                display: false  // Hide axis title
                            },
                            ticks: {
                                display: false  // Hide tick labels
                            },
                            grid: { 
                                display: false,
                                drawBorder: false  // Hide axis line
                            },
                            border: {
                                display: false  // Hide border
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            min: yMin,
                            max: yMax,
                            title: {
                                display: false  // Hide axis title
                            },
                            ticks: {
                                display: false  // Hide tick labels
                            },
                            grid: { 
                                display: false,
                                drawBorder: false  // Hide axis line
                            },
                            border: {
                                display: false  // Hide border
                            }
                        }
                    }
                }
            });
        }

        // Helpers for common operations
        const getCPH = (priceId, hoursId) => parseFloat(document.getElementById(priceId).value) / parseFloat(document.getElementById(hoursId).value);
        
        const getChartContext = (chartId, existingChart) => {
            if (existingChart) existingChart.destroy();
            return document.getElementById(chartId).getContext('2d');
        };

        function updateComparisonChart() {
            if (games.length === 0) return;
            
            // Calculate aggregate cost per hour
            const totalCost = games.reduce((sum, game) => sum + game.totalCost, 0);
            const totalHours = games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const aggregateCostPerHour = totalHours > 0 ? totalCost / totalHours : 0;
            
            // Get assumption values using helper
            const assumptions = {
                movie: getCPH('moviePrice', 'movieHours'),
                disney: getCPH('disneyPrice', 'disneyHours'),
                concert: getCPH('concertPrice', 'concertHours'),
                basketball: getCPH('basketballPrice', 'basketballHours'),
                netflix: getCPH('netflixPrice', 'netflixHours'),
                max: getCPH('maxPrice', 'maxHours'),
                youtube: getCPH('youtubePrice', 'youtubeHours'),
                gym: getCPH('gymPrice', 'gymHours'),
                spotify: getCPH('spotifyPrice', 'spotifyHours')
            };
            
            // Create array of all entertainment options with their data
            const entertainmentOptions = [
                { label: 'Your Gaming Collection', value: aggregateCostPerHour, isUserGame: true },
                { label: 'Movie Ticket', value: assumptions.movie, isUserGame: false },
                { label: 'Disneyland', value: assumptions.disney, isUserGame: false },
                { label: 'Concert Ticket', value: assumptions.concert, isUserGame: false },
                { label: 'Basketball Ticket', value: assumptions.basketball, isUserGame: false },
                { label: 'Netflix', value: assumptions.netflix, isUserGame: false },
                { label: 'HBO Max', value: assumptions.max, isUserGame: false },
                { label: 'YouTube Premium', value: assumptions.youtube, isUserGame: false },
                { label: 'Gym Membership', value: assumptions.gym, isUserGame: false },
                { label: 'Spotify Premium', value: assumptions.spotify, isUserGame: false }
            ];
            
            // Sort by cost per hour in descending order (highest to lowest)
            entertainmentOptions.sort((a, b) => b.value - a.value);
            
            // Extract sorted data for chart
            const sortedLabels = entertainmentOptions.map(option => option.label);
            const sortedData = entertainmentOptions.map(option => option.value);
            const sortedBackgroundColors = entertainmentOptions.map(option => 
                option.isUserGame ? 'rgba(74, 144, 226, 0.8)' : 'rgba(126, 211, 33, 0.6)'
            );
            const sortedBorderColors = entertainmentOptions.map(option => 
                option.isUserGame ? 'rgba(74, 144, 226, 1)' : 'rgba(126, 211, 33, 1)'
            );
            
            const chartData = {
                labels: sortedLabels,
                datasets: [{
                    label: 'Cost per Hour ($)',
                    data: sortedData,
                    backgroundColor: sortedBackgroundColors,
                    borderColor: sortedBorderColors,
                    borderWidth: 2
                }]
            };
            
            const chartConfig = {
                type: 'bar',
                data: chartData,
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Cost per hour ($)',
                                font: {
                                    family: 'Lucida Console, Monaco, Courier New, monospace'
                                },
                                color: '#2c5aa0'
                            },
                            grid: {
                                color: 'rgba(74, 144, 226, 0.2)'
                            }
                        },
                        y: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            };
            
            const ctx = getChartContext('comparisonChart', comparisonChart);
            comparisonChart = new Chart(ctx, chartConfig);
        }

        // Unified toggle function for expandable sections
        function toggleSection(content, toggle, displayType = 'block', symbols = ['‚ñº', '‚ñ≤']) {
            const isExpanded = content.classList ? content.classList.contains('expanded') : content.style.display !== 'none';
            
            if (content.classList) {
                content.classList.toggle('expanded');
            } else {
                content.style.display = isExpanded ? 'none' : displayType;
            }
            
            if (toggle) {
                toggle.textContent = isExpanded ? symbols[0] : symbols[1];
            }
        }
        
        const toggleAccordion = () => toggleSection(accordionContent, accordionToggle);
        const toggleGamesList = () => toggleSection(gamesList, gamesListToggle, 'flex', ['‚ñ∂', '‚ñº']);

        // Dynamically size scroll panes to show ~10 items
        function applyScrollableHeights() {
            try {
                // Games list: measure first .game-item
                const listPane = document.getElementById('gamesListContent');
                if (listPane) {
                    const firstItem = listPane.querySelector('.game-item');
                    if (firstItem) {
                        const itemH = firstItem.offsetHeight || 56; // fallback
                        listPane.style.maxHeight = (itemH * 10) + 'px';
                        listPane.style.overflowY = 'auto';
                    }
                }
                // Metrics table: include header + 10 data rows
                const metricsPane = document.getElementById('gamesMetrics');
                if (metricsPane) {
                    const headerRow = metricsPane.querySelector('table tr');
                    const dataRow = metricsPane.querySelector('table tr:nth-child(2)');
                    if (headerRow && dataRow) {
                        const h = headerRow.offsetHeight || 32;
                        const r = dataRow.offsetHeight || 40;
                        metricsPane.style.maxHeight = (h + r * 10) + 'px';
                        metricsPane.style.overflowY = 'auto';
                        metricsPane.style.display = 'block';
                    }
                }
            } catch (e) {
                // no-op
            }
        }

        window.addEventListener('resize', applyScrollableHeights);

        function resetAssumptions() {
            document.getElementById('moviePrice').value = 15;
            document.getElementById('movieHours').value = 2.5;
            document.getElementById('disneyPrice').value = 160;
            document.getElementById('disneyHours').value = 12;
            document.getElementById('netflixPrice').value = 16;
            document.getElementById('netflixHours').value = 40;
            document.getElementById('maxPrice').value = 16;
            document.getElementById('maxHours').value = 25;
            document.getElementById('youtubePrice').value = 14;
            document.getElementById('youtubeHours').value = 60;
            document.getElementById('concertPrice').value = 100;
            document.getElementById('concertHours').value = 3;
            document.getElementById('basketballPrice').value = 120;
            document.getElementById('basketballHours').value = 3;
            document.getElementById('gymPrice').value = 60;
            document.getElementById('gymHours').value = 12;
            document.getElementById('spotifyPrice').value = 11;
            document.getElementById('spotifyHours').value = 60;
            
            if (resultsCard.style.display !== 'none') {
                updateComparisonChart();
            }
        }

        function copySummary() {
            if (games.length === 0) {
                alert('No games to summarize.');
                return;
            }
            
            const totalCost = games.reduce((sum, game) => sum + game.totalCost, 0);
            const totalHours = games.reduce((sum, game) => sum + game.hoursPlayed, 0);
            const aggregateCostPerHour = totalCost / totalHours;
            
            const movieCPH = getCPH('moviePrice', 'movieHours');
            const netflixCPH = getCPH('netflixPrice', 'netflixHours');
            
            const movieComp = aggregateCostPerHour < movieCPH ? 'better' : 'worse';
            const netflixComp = aggregateCostPerHour < netflixCPH ? 'better' : 'worse';
            
            const summary = `I spent $${totalCost.toFixed(2)} on ${games.length} game${games.length > 1 ? 's' : ''}, played ${totalHours} hours total ‚Üí $${aggregateCostPerHour.toFixed(2)}/hr. That's ${netflixComp} than Netflix and ${movieComp} than a movie ticket.`;
            
            navigator.clipboard.writeText(summary).then(() => {
                shareStatus.textContent = 'Copied to clipboard!';
                setTimeout(() => shareStatus.textContent = '', 2000);
            });
        }

        // URL functions removed - legacy code from older version with income inputs
        
        // Parallax grid effect on scroll
        window.addEventListener('scroll', () => {
            document.documentElement.style.setProperty('--scroll-y', window.pageYOffset + 'px');
        });
    </script>
</body>
</html>
