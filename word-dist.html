<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Word Association Tunnel — Clean MVP</title>
<link rel="stylesheet" href="style.css">
<style>
  /* Page-specific styles for word-dist.html */
  :root {
    --card: #151924;
    --text: #e9ecf1;
    --muted: #9aa4bd;
    --accent: #5e9dc8;
    --good: #35c76d;
    --bad: #ff5a5a;
    --warn: #f2b84b;
  }

  * {
    box-sizing: border-box
  }

  html,
  body {
    height: 100%
  }

  body {
    margin: 0;
    font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    display: grid;
    place-items: center;
    padding: 16px
  }

  .app {
    width: 100%;
    max-width: 860px;
    background: var(--card);
    border: 1px solid #23293a;
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, .35);
    overflow: hidden
  }

  header {
    padding: 14px 18px;
    border-bottom: 1px solid #23293a
  }

  header h1 {
    margin: 0;
    font-size: 16px;
    letter-spacing: .2px;
    color: #dfe6f3
  }

  .hud {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    padding: 12px 16px
  }

  .hud-item {
    background: #0f1422;
    border: 1px solid #1f2740;
    border-radius: 14px;
    padding: 8px 10px;
    text-align: center
  }

  .hud-label {
    font-size: 12px;
    color: var(--muted);
    letter-spacing: .08em
  }

  .hud-value {
    font-size: clamp(40px, 12vw, 72px);
    font-weight: 900;
    line-height: 1.05
  }

  .board {
    padding: 8px 16px 16px;
    display: grid;
    gap: 14px
  }

  .pair {
    background: #0f1422;
    border: 1px solid #1f2740;
    border-radius: 14px;
    padding: 14px;
    display: grid;
    gap: 12px
  }

  .pair-row {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 8px;
    align-items: center
  }

  .word {
    font-size: clamp(26px, 8vw, 44px);
    font-weight: 800;
    text-align: center;
    padding: 10px;
    border-radius: 12px;
    background: #121729;
    border: 1px solid #22304a
  }

  .connector {
    color: var(--muted);
    font-weight: 700
  }

  .meters {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px
  }

  .meter {
    background: #0e1320;
    border: 1px solid #202a44;
    border-radius: 10px;
    padding: 10px 12px
  }

  .meter label {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 6px
  }

  .bar {
    position: relative;
    height: 12px;
    background: #141b2e;
    border-radius: 999px;
    overflow: hidden
  }

  .fill {
    position: absolute;
    inset: 0 auto 0 0;
    width: 0%;
    background: linear-gradient(90deg, var(--bad), #ff8a8a);
    transition: width .3s ease, background .2s ease
  }

  .input-row {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px
  }

  input[type=text] {
    background: #0b1020;
    border: 1px solid #23314e;
    color: var(--text);
    border-radius: 12px;
    padding: 16px;
    font-size: 18px;
    outline: none
  }

  input[type=text]:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(94, 157, 200, .18)
  }

  button {
    background: linear-gradient(180deg, #2b6e98, #255e82);
    border: 1px solid #2a6c95;
    color: #fff;
    font-weight: 800;
    letter-spacing: .3px;
    padding: 14px 16px;
    border-radius: 12px;
    cursor: pointer
  }

  button:disabled {
    opacity: .6;
    cursor: not-allowed
  }

  .controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap
  }

  .btn-secondary {
    background: #1c2333;
    border: 1px solid #2a3348
  }

  .btn-warn {
    background: #3a2b10;
    border: 1px solid #5a4315
  }

  .toast {
    position: fixed;
    top: 14px;
    left: 50%;
    transform: translateX(-50%);
    background: #101522;
    border: 1px solid #2a3348;
    color: #fff;
    padding: 10px 14px;
    border-radius: 10px;
    opacity: 0;
    transition: opacity .15s ease
  }

  .toast.show {
    opacity: 1
  }

  .footer {
    padding: 10px 16px;
    border-top: 1px solid #23293a;
    color: var(--muted);
    font-size: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center
  }

  .kbd {
    border: 1px solid #30384e;
    background: #1a2030;
    padding: 2px 6px;
    border-radius: 6px;
    color: #c6d2e8;
    font-weight: 700;
    font-size: 12px
  }

  @media (max-width:560px) {
    .hud {
      grid-template-columns: 1fr
    }

    .meters {
      grid-template-columns: 1fr
    }

    .input-row {
      grid-template-columns: 1fr
    }

    button {
      width: 100%
    }
  }
</style>
</head>

<body>
  <div class="app">
    <header>
      <h1>Word Association Tunnel</h1>
    </header>

    <div class="hud">
      <div class="hud-item">
        <div class="hud-label">TIMER</div>
        <div class="hud-value" id="time">—</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">STREAK</div>
        <div class="hud-value" id="streak">0</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">SCORE</div>
        <div class="hud-value" id="score">0</div>
      </div>
    </div>

    <div class="board">
      <div class="pair">
        <div class="pair-row">
          <div class="word" id="wordA">…</div>
          <div class="connector">⟶</div>
          <div class="word" id="wordB">…</div>
        </div>
        <div class="meters">
          <div class="meter">
            <label><span>rel(A, C)</span><span id="r1v">0.00</span></label>
            <div class="bar">
              <div class="fill" id="r1"></div>
            </div>
          </div>
          <div class="meter">
            <label><span>rel(C, B)</span><span id="r2v">0.00</span></label>
            <div class="bar">
              <div class="fill" id="r2"></div>
            </div>
          </div>
        </div>
        <div class="input-row">
          <input id="guess" type="text" placeholder="Type a bridge word…" autocomplete="off" />
          <button id="submit">Submit ↵</button>
        </div>
        <div class="controls">
          <button id="skip" class="btn-warn">Skip Pair</button>
          <button id="reset" class="btn-secondary">Reset</button>
        </div>
      </div>
    </div>

    <div class="footer">
      <div>Connect <strong>A</strong> and <strong>B</strong>. Both meters must reach the hidden threshold.</div>
      <div><span class="kbd">Enter</span> submit</div>
    </div>
  </div>

  <div class="toast" id="toast">Toast</div>

  <script>
    const $ = s => document.querySelector(s);
    const UI = {
      A: $('#wordA'), B: $('#wordB'), score: $('#score'), streak: $('#streak'),
      time: $('#time'), r1: $('#r1'), r2: $('#r2'), r1v: $('#r1v'), r2v: $('#r2v'),
      guess: $('#guess'), submit: $('#submit'), skip: $('#skip'), reset: $('#reset'), toast: $('#toast')
    };

    const deny = new Set(['thing', 'object', 'stuff', 'good', 'bad', 'nice', 'okay', 'something', 'everything', 'anything', 'person', 'entity', 'item']);

    const commonNouns = [
      'fire', 'ice', 'water', 'stone', 'paper', 'music', 'money', 'love', 'war', 'peace', 'game', 'food', 'animal', 'plant', 'river', 'mountain', 'beach', 'sand', 'forest', 'computer', 'phone', 'book', 'movie', 'city', 'village', 'school', 'teacher', 'student', 'doctor', 'hospital', 'car', 'train', 'airplane', 'coffee', 'tea', 'sugar', 'salt', 'bread', 'cheese', 'fish', 'bird', 'cat', 'dog', 'house', 'home', 'family', 'friend', 'party', 'work', 'job', 'art', 'dance', 'song', 'light', 'dark', 'shadow', 'mirror', 'glass', 'window', 'door', 'key', 'lock', 'map', 'journey', 'travel', 'flight', 'storm', 'rain', 'snow', 'wind', 'sun', 'moon', 'star', 'planet', 'space', 'time', 'history', 'science', 'energy', 'power', 'sport', 'team', 'ball', 'goal', 'ocean', 'lake', 'island', 'bridge', 'road', 'path', 'desert', 'garden', 'flower', 'tree', 'leaf', 'root', 'seed'
    ];

    const curatedPairs = [
      ['cat', 'milk'], ['sun', 'beach'], ['paper', 'pen'], ['doctor', 'hospital'],
      ['coffee', 'morning'], ['rain', 'umbrella'], ['music', 'dance'], ['bird', 'nest']
    ];


    const state = {
      A: 'fire', B: 'ice', score: 0, streak: 0,
      threshold: 0.05, timer: null, baseTime: 12, timeLeft: 12,
      relAB: 0
    };

    // ==== Utility helpers ====
    async function fetchWithTimeout(url, { timeout = 500, ...opts } = {}) {
      const ctrl = new AbortController();
      const id = setTimeout(() => ctrl.abort(), timeout);
      try { return await fetch(url, { signal: ctrl.signal, ...opts }); }
      finally { clearTimeout(id); }
    }

    function sanitize(w) {
      if (!w) return '';
      w = w.toLowerCase().trim();
      w = w.normalize('NFKD').replace(/[̀-ͯ]/g, '');
      if (w.endsWith('ies') && w.length > 4) w = w.slice(0, -3) + 'y';
      else if (w.endsWith('ses') || w.endsWith('xes')) w = w.slice(0, -2);
      else if (w.endsWith('s') && !w.endsWith('ss') && w.length > 3) w = w.slice(0, -1);
      return w.replace(/[^a-z\- ]/g, '');
    }

    function toast(msg) { UI.toast.textContent = msg; UI.toast.classList.add('show'); setTimeout(() => UI.toast.classList.remove('show'), 1100); }
    function updateHUD() { UI.score.textContent = state.score; UI.streak.textContent = state.streak; }

    function stopTimer() { if (state.timer) { clearInterval(state.timer); state.timer = null; } }
    function startTimer() {
      stopTimer();
      state.timeLeft = state.baseTime;
      UI.time.textContent = state.timeLeft.toFixed(1) + 's';
      state.timer = setInterval(() => {
        state.timeLeft -= 0.1;
        if (state.timeLeft <= 0) { stopTimer(); onFail('Time up!'); }
        else UI.time.textContent = state.timeLeft.toFixed(1) + 's';
      }, 100);
    }

    // ==== ConceptNet + Datamuse caches ====
    const relCache = new Map();
    const relKey = (a, b) => { a = a.toLowerCase(); b = b.toLowerCase(); return a < b ? a + '|' + b : b + '|' + a; };
    const save = (k, v) => { try { localStorage.setItem('rel:' + k, String(v)); } catch { } };
    const load = (k) => { try { const v = localStorage.getItem('rel:' + k); return v ? Number(v) : null; } catch { return null; } };

    async function conceptnetRel(a, b, timeout = 500) {
      if (!a || !b) return 0;
      const key = relKey(a, b);
      if (relCache.has(key)) return relCache.get(key);
      const vStored = load(key); if (vStored !== null) { relCache.set(key, vStored); return vStored; }
      const url = `https://api.conceptnet.io/relatedness?node1=/c/en/${encodeURIComponent(a)}&node2=/c/en/${encodeURIComponent(b)}`;
      try {
        const res = await fetchWithTimeout(url, { timeout });
        const j = await res.json();
        const v = Number(j.value || 0) || 0;
        relCache.set(key, v); save(key, v);
        return v;
      } catch { return 0; }
    }

    // Use existing global if present (prevents redefinition across script tags)
    window.dmCache = window.dmCache || new Map();
    const dmCache = window.dmCache;

    async function datamuseProfile(term, timeout = 500) {
      term = sanitize(term);
      if (dmCache.has(term)) return dmCache.get(term);
      try {
        const url = `https://api.datamuse.com/words?ml=${encodeURIComponent(term)}&max=100`;
        const r = await fetchWithTimeout(url, { timeout });
        const arr = await r.json();
        let top = 0; const map = new Map();
        for (const x of arr) {
          const w = sanitize(x.word); const s = Number(x.score || 0);
          if (!w) continue;
          if (s > top) top = s;
          if (!map.has(w) || map.get(w) < s) map.set(w, s);
        }
        const prof = { top: top || 1, map };
        dmCache.set(term, prof);
        return prof;
      } catch {
        const prof = { top: 1, map: new Map() };
        dmCache.set(term, prof);
        return prof;
      }
    }


    async function datamuseRel(a, b, timeout = 500) {
      a = sanitize(a); b = sanitize(b);
      if (!a || !b) return 0;
      const [pa, pb] = await Promise.all([datamuseProfile(a, timeout), datamuseProfile(b, timeout)]);
      const s1 = pa.map.get(b) ? (pa.map.get(b) / pa.top) : 0;
      const s2 = pb.map.get(a) ? (pb.map.get(a) / pb.top) : 0;
      const sym = Math.max(s1, s2);
      return Math.sqrt(sym);
    }

    function diceCoeff(a, b) {
      a = sanitize(a); b = sanitize(b);
      if (!a || !b) return 0;
      if (a === b) return 1;
      const bigrams = s => { const v = []; for (let i = 0; i < s.length - 1; i++)v.push(s.slice(i, i + 2)); return v; };
      const A = bigrams(a), B = bigrams(b);
      const setB = new Map(); for (const x of B) setB.set(x, (setB.get(x) || 0) + 1);
      let overlap = 0; for (const x of A) { const c = setB.get(x) || 0; if (c > 0) { overlap++; setB.set(x, c - 1); } }
      return (2 * overlap) / (A.length + B.length);
    }

    // ==== Staged blended relatedness ====
    async function blendedRel(a, b, { dmTimeout = 500, cnTimeout = 500 } = {}) {
      const morph = diceCoeff(a, b);
      const dm = await datamuseRel(a, b, dmTimeout);

      if (dm >= 0.35 || dm <= 0.05) {
        const score = 0.8 * dm + 0.2 * morph;
        return Math.max(0, Math.min(1, score));
      }

      const cnet = await conceptnetRel(a, b, cnTimeout);
      const score = 0.55 * cnet + 0.3 * dm + 0.15 * morph;
      return Math.max(0, Math.min(1, score));
    }

    function bridgeScore(r1, r2) {
      if (r1 <= 0 || r2 <= 0) return 0;
      return (2 * r1 * r2) / (r1 + r2);
    }

    function setMeters(r1, r2) {
      UI.r1.style.width = Math.max(0, Math.min(1, r1)) * 100 + '%';
      UI.r2.style.width = Math.max(0, Math.min(1, r2)) * 100 + '%';
      UI.r1v.textContent = r1.toFixed(2);
      UI.r2v.textContent = r2.toFixed(2);
      UI.r1.style.background = r1 >= state.threshold ? 'linear-gradient(90deg,var(--good),#55d98c)' : 'linear-gradient(90deg,var(--bad),#ff8a8a)';
      UI.r2.style.background = r2 >= state.threshold ? 'linear-gradient(90deg,var(--good),#55d98c)' : 'linear-gradient(90deg,var(--bad),#ff8a8a)';
    }

    function adaptDifficultyForPair() {
      const bump = Math.floor(state.streak / 5);
      const base = 0.10 + 0.40 * state.relAB;
      state.threshold = Math.max(0.08, Math.min(0.25, base + bump * 0.01));
      state.baseTime = Math.max(6, 12 - bump);
    }

    // ==== Faster seed picking + prefetch ====
    let nextPair = null;

    async function pickSeedPairSmart() {
      // Phases: gradually relax morphology + relatedness windows
      const phases = [
        { tries: 40, mMin: 0.02, mMax: 0.22, relMin: 0.05, relMax: 0.30, dmMs: 700, cnMs: 700 },
        { tries: 40, mMin: 0.00, mMax: 0.28, relMin: 0.04, relMax: 0.36, dmMs: 800, cnMs: 800 },
        { tries: 40, mMin: 0.00, mMax: 0.34, relMin: 0.03, relMax: 0.42, dmMs: 900, cnMs: 900 },
      ];

      for (const ph of phases) {
        for (let i = 0; i < ph.tries; i++) {
          const a = commonNouns[Math.floor(Math.random() * commonNouns.length)];
          const b = commonNouns[Math.floor(Math.random() * commonNouns.length)];
          if (a === b) continue;

          const m = diceCoeff(a, b);
          if (m < ph.mMin || m > ph.mMax) continue;

          const relAB = await blendedRel(a, b, { dmTimeout: ph.dmMs, cnTimeout: ph.cnMs });
          if (relAB >= ph.relMin && relAB <= ph.relMax) return { a, b, relAB };
        }
      }

      // Curated fallback rotation (never "fire/ice" unless everything fails)
      const pick = curatedPairs[Math.floor(Math.random() * curatedPairs.length)];
      return { a: pick[0], b: pick[1], relAB: await blendedRel(pick[0], pick[1], { dmTimeout: 900, cnTimeout: 900 }) };
    }

    // queueNextPair
    async function queueNextPair() {
      try { nextPair = await pickSeedPairSmart(); } catch { nextPair = null; }
    }

    // advanceToNextPair
    async function advanceToNextPair() {
      if (nextPair) {
        const { a, b } = nextPair;
        nextPair = null;
        await setPair(a, b);
      } else {
        const { a, b } = await pickSeedPairSmart();
        await setPair(a, b);
      }
    }

    // ==== Core game flow ====
    async function setPair(a, b) {
      state.A = a; state.B = b;
      UI.A.textContent = a; UI.B.textContent = b;
      state.relAB = await blendedRel(a, b);
      adaptDifficultyForPair();
      setMeters(0, 0); UI.guess.value = ''; UI.guess.focus();
      startTimer();
      queueNextPair(); // prefetch next
    }

    // startGame
    async function startGame() {
      state.score = 0; state.streak = 0; state.threshold = 0.12; state.baseTime = 12; updateHUD();
      const { a, b } = await pickSeedPairSmart();
      await setPair(a, b);
    }

    async function onSubmit() {
      stopTimer();
      let c = sanitize(UI.guess.value);
      if (!c) { toast('Enter a word'); return; }
      if (deny.has(c)) { toast('Too generic'); return; }
      if (c === state.A || c === state.B) { toast('Must differ from A and B'); return; }

      UI.submit.disabled = true;
      const [r1, r2] = await Promise.all([blendedRel(state.A, c), blendedRel(c, state.B)]);
      setMeters(r1, r2);
      const bridge = bridgeScore(r1, r2);
      const ok = bridge >= state.threshold;

      if (ok) {
        state.score += 100; state.streak += 1; updateHUD(); toast('+100');
        await advanceToNextPair(); // instant next pair
      } else {
        onFail('Bridge rejected');
      }
      UI.submit.disabled = false;
    }

    async function onSkip() {
      state.streak = 0; updateHUD(); toast('New pair');
      await advanceToNextPair();
    }

    function onFail(reason) {
      toast(`${reason} — streak ${state.streak}`);
      state.streak = 0; updateHUD();
    }

    // ==== Warm Datamuse cache (optional) ====
    (function warmDatamuse() {
      const seeds = commonNouns.slice(0, 20);
      for (const w of seeds) datamuseProfile(w);
    })();

    // ==== Events + boot ====
    UI.submit.addEventListener('click', onSubmit);
    UI.skip.addEventListener('click', onSkip);
    UI.reset.addEventListener('click', startGame);
    UI.guess.addEventListener('keydown', e => { if (e.key === 'Enter') onSubmit(); });

    (async () => { await startGame(); })();
  </script>

</body>

</html>